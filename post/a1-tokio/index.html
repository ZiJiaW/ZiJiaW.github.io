<!DOCTYPE html>
<html lang="zh"><head>
	
	<meta name="generator" content="Hugo 0.80.0" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	
	<meta property="og:title" content="Tokio Guide 中文翻译">
	
	
	<meta name="author" content="Allan Wang"><meta name="keywords" content="Rust,Tokio"><meta name="description" content="读了下新版tokio文档，顺便翻译"><meta property="og:title" content="Tokio Guide 中文翻译" />
<meta property="og:description" content="读了下新版tokio文档，顺便翻译" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zijiaw.github.io/post/a1-tokio/" />
<meta property="article:published_time" content="2021-01-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-01-18T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tokio Guide 中文翻译"/>
<meta name="twitter:description" content="读了下新版tokio文档，顺便翻译"/>

	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" />
	<link rel="stylesheet" href="/css/katex.min.css" crossorigin="anonymous">
	<script defer src="/js/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
	<script defer src="/js/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script><title>Tokio Guide 中文翻译 | 一只特立独行的猫</title></head>
<body><header>
	
	<div id="avatar">
		<a href="https://zijiaw.github.io/">
		  <img src="/img/avatar.jpg" alt="一只特立独行的猫">
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://zijiaw.github.io/">一只特立独行的猫</a></h2></div>
	<div id="title-description"><p id="subtitle">记录一些笔记、翻译、感想</p><div id="social">
			<nav>
				<ul>
					<li><a href="https://github.com/ZiJiaW/"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="mailto:zijiaw@outlook.com"><i title="Email" class="icons fas fa-envelope"></i></a></li></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/">Home</a></li>
				
				<li><a href="/post">All Posts</a></li>
				
				<li><a href="/about">About</a></li>
				
				<li><a href="/tags">Tags</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">18</span>
				<span class="rest">Jan 2021</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">Tokio Guide 中文翻译</h1>
		</div>
	</div>
	<div class="markdown">
		<h1 id="intruduction">Intruduction</h1>
<p>本教程将一步步带你构建一个简化的Redis客户端和服务器。我们首先介绍Rust中异步编程的基本概念，而后实现Redis命令的一个子集。</p>
<h2 id="mini-redis">Mini-Redis</h2>
<p>安装完成Rust以后，请安装Mini-Redis服务器程序，这可以用来测试我们的程序：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">cargo install mini-redis
</code></pre></div><p>你可以键入如下命令开始程序：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">mini-redis-server
</code></pre></div><p>而后你可以另起一个命令行，用自带的客户端程序尝试获取键<code>foo</code>：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">mini-redis-cli get foo
</code></pre></div><p>你将看到输出为<code>nil</code>。</p>
<h1 id="hello-tokio">Hello Tokio</h1>
<h2 id="引入">引入</h2>
<p>我们首先编写非常基础的Tokio应用，它将连接到我们的Mini-Redis服务器，插入键值对<code>&lt;hello, world&gt;</code>，而后我们用<code>cli</code>包来获取它，以验证正确性。</p>
<p>首先我们用carge创建新的Rust应用目录：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">cargo new my-redis
cd my-redis
</code></pre></div><p>而后编辑<code>Cargo.toml</code>，添加依赖：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">tokio = { version = &#34;0.3&#34;, features = [&#34;full&#34;] }
mini-redis = &#34;0.3&#34;
</code></pre></div><p>现在我们可以编辑<code>main.rs</code>，代码如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::{client,<span style="color:#bbb"> </span><span style="color:#007020">Result</span>};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Open a connection to the mini-redis address.
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>client<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>client::connect(<span style="background-color:#fff0f0">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Set the key &#34;hello&#34; with value &#34;world&#34;
</span><span style="color:#888"></span><span style="color:#bbb">    </span>client.set(<span style="background-color:#fff0f0">&#34;hello&#34;</span>,<span style="color:#bbb"> </span><span style="background-color:#fff0f0">&#34;world&#34;</span>.into()).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Get key &#34;hello&#34;
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>result<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>client.get(<span style="background-color:#fff0f0">&#34;hello&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;got value from the server; result={:?}&#34;</span>,<span style="color:#bbb"> </span>result);<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#007020">Ok</span>(())<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>现在请在另一个终端运行server，然后运行main，你将得到：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">cargo run
got value from the server; result=Some(b&#34;world&#34;)
</code></pre></div><h2 id="分析">分析</h2>
<p>我们来看看我们刚刚的程序做了什么，实际上没有几行代码，但是确实发生了很多事情。首先，<code>client::connect</code>函数由mini-redis包提供，它异步地创建了一个TCP连接。一旦连接建立完成，一个<code>client</code>句柄将被返回。即使整个过程是异步的，但是我们看到的代码似乎是同步的，唯一的暗示在于我们用到的<code>await</code>操作符。</p>
<h3 id="什么是异步编程">什么是异步编程</h3>
<p>大多是程序的运行顺序和编写顺序是一致的，首先执行第一行，然后第二行，以此类推。在同步编程中，如果程序遇到一条无法立即返回的指令，它将阻塞在这里，直到指令完成。例如，创建一个TCP连接需要三次握手，这可能花费很长时间，在同步编程中，当前线程将会阻塞。</p>
<p>在异步编程中，无法立刻返回的指令将被暂停挂在后台，而当前线程可以继续执行其他操作。一旦该指令完成，任务将重新在暂停的地方开始被恢复执行。我们的例子中只有一个任务，所以在挂起的时候程序没干别的事情，但是通常异步程序会拥有很多异步任务需要调度。</p>
<p>尽管异步编程可以使程序运行更高效，但它也使得程序逻辑变得复杂。程序员需要考虑所有必要的状态来恢复暂停的任务。历史上，这是一件很冗杂无聊和易出错的事情。</p>
<h3 id="编译时绿色线程">编译时绿色线程</h3>
<p>Rust使用<code>async/await</code>特性来实现异步编程。所有包含异步操作的函数使用<code>async</code>来标记，在我们上面的例子中，<code>connect</code>函数的定义如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::<span style="color:#007020">Result</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::client::Client;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::ToSocketAddrs;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">connect</span><span style="color:#333">&lt;</span>T: <span style="color:#b06;font-weight:bold">ToSocketAddrs</span><span style="color:#333">&gt;</span>(addr: <span style="color:#b06;font-weight:bold">T</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#007020">Result</span><span style="color:#333">&lt;</span>Client<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// ...
</span><span style="color:#888"></span>}<span style="color:#bbb">
</span></code></pre></div><p>这里的<code>async fn</code>的定义看起来和普通的同步函数一样，但是执行的时候是异步的。Rust在编译时就将异步函数转换成一个异步的任务。在异步函数内调用<code>await</code>时，调度器会把当前任务挂起，转而在此线程上执行其他任务，此异步任务将在别处处理（操作系统接受网络数据，或者读取文件等等）。</p>
<blockquote>
<p>其他一些语言也实现了<code>async/await</code>特性，但是Rust的实现方式是独特的。Rust的async操作是lazy的，这使得其运行时语义不同于其他语言。</p>
</blockquote>
<p>如果目前为止的内容你还难以理解，别担心，我们后续会有更详细的解释。</p>
<h3 id="使用asyncawait">使用async/await</h3>
<p>异步函数的调用和普通函数无异。然而，单单调用并不会执行这些函数的函数体。调用一个async函数仅仅是返回一个代表这一异步操作的值，这在概念上类似于一个无参数的闭包。我们必须显式调用<code>.await</code>操作符才能获得函数真正的返回值。看下面的代码：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">say_world</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;world&#34;</span>);<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Calling `say_world()` does not execute the body of `say_world()`.
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>op<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>say_world();<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// This println! comes first
</span><span style="color:#888"></span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;hello&#34;</span>);<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Calling `.await` on `op` starts executing `say_world`.
</span><span style="color:#888"></span><span style="color:#bbb">    </span>op.<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>这段代码输出：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">hello
world
</code></pre></div><p>实际上，异步函数的返回值是一个实现了<code>Future</code>的匿名类型值。</p>
<h3 id="异步的main函数">异步的main函数</h3>
<p>上面的程序中的main函数和通常的Rust应用不同，它是异步的，并且使用<code>#[tokio::main]</code>作了注解。当我们在函数中用到异步操作符的时候，该函数需要定义为async的。而async函数必须要用一个运行时去执行。该运行时需要包含异步任务调度器，并且提供内部的定时器，事件驱动型的IO框架等。这一运行时也需要main函数来启动。</p>
<p><code>#[tokio::main]</code>是一个宏，它将<code>async fn main()</code>转化为一个同步的<code>main()</code>函数，并在其中初始化运行时并执行异步的main函数。例如，下面一段程序：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;hello&#34;</span>);<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>将被转化成：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>rt<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::runtime::Runtime::new().unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>rt.block_on(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;hello&#34;</span>);<span style="color:#bbb">
</span><span style="color:#bbb">    </span>})<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>Tokio运行时的细节将在后面谈到。</p>
<h3 id="cargo-features">Cargo features</h3>
<p>当用到tokio的时候，我们设置了features为full：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml">tokio = { version = <span style="background-color:#fff0f0">&#34;0.3&#34;</span>, features = [<span style="background-color:#fff0f0">&#34;full&#34;</span>] }
</code></pre></div><p>Tokio本身有很多功能（TCP, UDP, Unix sockets, timers, sync utilities, multple scheduler types, etc）。并不是所有应用都会用到全部的功能。当我们尝试优化应用的编译时长或最终生成的软件大小时，可以砍掉一些没有用到的feature。</p>
<p>但是目前为止，我们直接使用full就好了。</p>
<h1 id="spawning">Spawning</h1>
<p>我们现在真正开始实现我们的Redis服务。首先我们把上一节用到的代码移到example包里，我们可以用它来测试我们自己的Redis服务器。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">mkdir -p examples
mv src/main.rs examples/hello-redis.rs
</code></pre></div><p>然后我们新建一个空的<code>src/main.rs</code>文件。</p>
<h2 id="接受新的socket连接">接受新的socket连接</h2>
<p>Redis服务器第一件要干的事情就是监听固定端口上的TCP连接请求，这可以用<code>tokio::net::TcpListener</code>完成。</p>
<blockquote>
<p>许多Tokio的内部类型都和Rust标准库里的同步等价物命名相同。Tokio合理地将标准库里地一些API以异步的方式重新暴露给用户使用。</p>
</blockquote>
<p>一个TcpListener绑定带6379号端口，而后我们在一个循环中接收连接，每一个连接都被处理一次，然后关闭。目前，我们只读取接受到的命令然后输出到stdout，然后向客户端响应一个error。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::{TcpListener,<span style="color:#bbb"> </span>TcpStream};<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::{Connection,<span style="color:#bbb"> </span>Frame};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Bind the listener to the address
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>listener<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>TcpListener::bind(<span style="background-color:#fff0f0">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// The second item contains the IP and port of the new connection.
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(socket,<span style="color:#bbb"> </span>_)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>listener.accept().<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">        </span>process(socket).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">process</span>(socket: <span style="color:#b06;font-weight:bold">TcpStream</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// The `Connection` lets us read/write redis **frames** instead of
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// byte streams. The `Connection` type is defined by mini-redis.
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>connection<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Connection::new(socket);<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(frame)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>connection.read_frame().<span style="color:#080;font-weight:bold">await</span>.unwrap()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;GOT: {:?}&#34;</span>,<span style="color:#bbb"> </span>frame);<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Respond with an error
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>response<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Frame::Error(<span style="background-color:#fff0f0">&#34;unimplemented&#34;</span>.to_string());<span style="color:#bbb">
</span><span style="color:#bbb">        </span>connection.write_frame(<span style="color:#333">&amp;</span>response).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>现在我们运行一下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">cargo run
</code></pre></div><p>在另一个终端我们运行之前的example的hello-redis：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">cargo run --example hello-redis
</code></pre></div><p>输出应该是：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">Error: &#34;unimplemented&#34;
</code></pre></div><p>在服务器的终端上应该显示如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">GOT: Array([Bulk(b&#34;set&#34;), Bulk(b&#34;hello&#34;), Bulk(b&#34;world&#34;)])
</code></pre></div><h2 id="并发执行">并发执行</h2>
<p>除了只返回error以外，上面的程序有一个小问题，它只能一次处理一个连接。当一个连接被接受以后，服务器程序将执行process程序，处理完成后才开始接受新的请求。</p>
<p>我们希望我们的Redis服务器能够同时处理大量请求，这需要一些并发。</p>
<blockquote>
<p>并发和并行不是一个东西。如果你在两个任务之间来回切换，你是在并发执行两个任务，但并非并行。并行指的是你必须有两个不同的个体各自同时执行一个任务。在计算机中，达到并行必须使用多个线程在多核处理器上运行。</p>
<p>使用Tokio的好处在于异步编程能够让许多任务并发执行，而不需要手动开启多个原生线程。事实上，Tokio调度器可以让许多任务在单线程上并发执行。</p>
</blockquote>
<p>为了并发地处理连接请求，我们需要在每一次连接到来的时候发布（spawn）一个新的任务，此任务包含连接的处理逻辑，我们把main函数改成这样：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpListener;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>listener<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>TcpListener::bind(<span style="background-color:#fff0f0">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(socket,<span style="color:#bbb"> </span>_)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>listener.accept().<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// A new task is spawned for each inbound socket. The socket is
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// moved to the new task and processed there.
</span><span style="color:#888"></span><span style="color:#bbb">        </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span>process(socket).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span>});<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><h3 id="任务">任务</h3>
<p>一个Tokio任务就是一个异步的绿色线程（或者说协程也不为过）。它们通过一个async块来创建，然后传入<code>tokio::spawn</code>函数来发布，该函数返回一个<code>JoinHandle</code>，调用者可以通过这一句柄和该任务交互。该async块有时会有返回值，可以通过在<code>JoinHandle</code>上调用<code>.await</code>来获得它。例如：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>handle<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Do some async work
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="background-color:#fff0f0">&#34;return value&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>});<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Do some other work
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>out<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>handle.<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;GOT {}&#34;</span>,<span style="color:#bbb"> </span>out);<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>在该句柄上await将得到一个<code>Result</code>，如果任务执行过程中产生错误，会返回<code>Err</code>，这通常发生在任务发生panic，或者运行时异常宕机导致任务被取消的情况下。</p>
<p>Tokio任务是Tokio调度器管理的执行单元。当我们将任务发布后，该任务被提交给调度器，由调度器负责其执行。每一个任务可能就在当前线程执行，也可能被调度到不同的线程，也有可能在不同线程间切换。</p>
<p>Tokio中的任务是非常轻量级的，实际上创建它们仅消耗一次内存分配以及64字节的内存。你可以随意发布任务，当然别弄个几百万个就好。</p>
<h3 id="static限制">&lsquo;static限制</h3>
<p>当你发布一个任务时，它的类型必须是静态`static的，这意味着任务不能包含任何任务外部数据的引用。</p>
<blockquote>
<p>&lsquo;static并不总是意味着永生，一个值是&rsquo;static的并不意味着内存泄漏：你可以在<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#2-if-t-static-then-t-must-be-valid-for-the-entire-program" target="_blank">Common Rust Lifetime Misconceptions</a>上阅读更多。</p>
</blockquote>
<p>例如，下述代码无法编译通过：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::task;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>v<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>vec<span style="color:#333">!</span>[<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">2</span>,<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">3</span>];<span style="color:#bbb">
</span><span style="color:#bbb">    </span>task::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;Here&#39;s a vec: {:?}&#34;</span>,<span style="color:#bbb"> </span>v);<span style="color:#bbb">
</span><span style="color:#bbb">    </span>});<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>如果你尝试编译，将会出现如下的报错：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">error[E0373]: async block may outlive the current function, but
              it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:7:23
  |
7 |       task::spawn(async {
  |  _______________________^
8 | |         println!(&#34;Here&#39;s a vec: {:?}&#34;, v);
  | |                                        - `v` is borrowed here
9 | |     });
  | |_____^ may outlive borrowed value `v`
  |
note: function requires argument type to outlive `&#39;static`
 --&gt; src/main.rs:7:17
  |
7 |       task::spawn(async {
  |  _________________^
8 | |         println!(&#34;Here&#39;s a vector: {:?}&#34;, v);
9 | |     });
  | |_____^
help: to force the async block to take ownership of `v` (and any other
      referenced variables), use the `move` keyword
  |
7 |     task::spawn(async move {
8 |         println!(&#34;Here&#39;s a vec: {:?}&#34;, v);
9 |     });
  |
</code></pre></div><p>这是因为，默认情况下，变量不会被移动到async块内，这里的<code>v</code>的所有权仍然归main函数，而<code>println!</code>借用了<code>v</code>。编译器解释了这一错误，并建议使用<code>move</code>关键字把<code>v</code>移动进去。修改后，任务就拥有了所有内部数据的所有权，成为&rsquo;static的了。如果你一定要让多个任务共享一个变量，则它必须用一些同步原语来包装，如线程安全的多重所有权指针<code>Arc</code>。</p>
<p>注意到错误信息提示：参数类型需要比&rsquo;static活得长。这听起来有点令人困惑，因为&rsquo;static变量的生命期等同整个程序，如果它比&rsquo;static活得长，岂不是内存泄漏了吗？解释如下：是类型需要活得长，而不是变量本身，变量在类型无效前就可以被销毁。</p>
<p>当我们说一个值是&rsquo;static的时候，它仅仅意味着：任意传递这个变量都不会出错。这很重要，因为编译器无法推断一个新发布的任务会存活多长时间，所以唯一的方法就是假定它可能会永生。</p>
<h3 id="send限制">Send限制</h3>
<p>被发布的任务必须实现了<code>Send</code>，这允许Tokio运行时将任务在不同线程间切换。当所有生命期跨过<code>.await</code>语句的变量是<code>Send</code>的时候，该任务是<code>Send</code>的。这有点微妙。当<code>.await</code>被调用时，任务挂起，然后调度器调度其他任务。下次这个任务被唤醒时，将在挂起的时候重新恢复执行，也就是说在<code>.await</code>之后用到的所有变量都会被保存。而恢复执行的线程可能不同于原来的线程，因此这些变量需要是<code>Send</code>的。</p>
<p>例如，下面这段代码是正确的，因为变量<code>rc</code>提前释放了，它没有跨越<code>await</code>：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::task::yield_now;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::rc::Rc;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// The scope forces `rc` to drop before `.await`.
</span><span style="color:#888"></span><span style="color:#bbb">        </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>rc<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Rc::new(<span style="background-color:#fff0f0">&#34;hello&#34;</span>);<span style="color:#bbb">
</span><span style="color:#bbb">            </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;{}&#34;</span>,<span style="color:#bbb"> </span>rc);<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// `rc` is no longer used. It is **not** persisted when
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// the task yields to the scheduler
</span><span style="color:#888"></span><span style="color:#bbb">        </span>yield_now().<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>});<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>而下面这段代码无法编译通过：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::task::yield_now;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::rc::Rc;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>rc<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Rc::new(<span style="background-color:#fff0f0">&#34;hello&#34;</span>);<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// `rc` is used after `.await`. It must be persisted to
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// the task&#39;s state.
</span><span style="color:#888"></span><span style="color:#bbb">        </span>yield_now().<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;{}&#34;</span>,<span style="color:#bbb"> </span>rc);<span style="color:#bbb">
</span><span style="color:#bbb">    </span>});<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>编译错误如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">error: future cannot be sent between threads safely
   --&gt; src/main.rs:6:5
    |
6   |     tokio::spawn(async {
    |     ^^^^^^^^^^^^ future created by async block is not `Send`
    | 
   ::: [..]spawn.rs:127:21
    |
127 |         T: Future + Send + &#39;static,
    |                     ---- required by this bound in
    |                          `tokio::task::spawn::spawn`
    |
    = help: within `impl std::future::Future`, the trait
    |       `std::marker::Send` is not  implemented for
    |       `std::rc::Rc&lt;&amp;str&gt;`
note: future is not `Send` as this value is used across an await
   --&gt; src/main.rs:10:9
    |
7   |         let rc = Rc::new(&#34;hello&#34;);
    |             -- has type `std::rc::Rc&lt;&amp;str&gt;` which is not `Send`
...
10  |         yield_now().await;
    |         ^^^^^^^^^^^^^^^^^ await occurs here, with `rc` maybe
    |                           used later
11  |         println!(&#34;{}&#34;, rc);
12  |     });
    |     - `rc` is later dropped here
</code></pre></div><p>我们将在下一节深入讨论这个错误的一个特殊情况。</p>
<h3 id="保存数据">保存数据</h3>
<p>我们现在实现新的<code>process</code>函数，来处理新到达的请求。我们使用<code>HashMap</code>来保存数据。<code>SET</code>命令把数据存到哈希表中，而<code>GET</code>命令读取它们。同时我们循环读取一次连接中的多个命令。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpStream;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::{Connection,<span style="color:#bbb"> </span>Frame};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">process</span>(socket: <span style="color:#b06;font-weight:bold">TcpStream</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::Command::{self,<span style="color:#bbb"> </span>Get,<span style="color:#bbb"> </span>Set};<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::collections::HashMap;<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// A hashmap is used to store data
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>db<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>HashMap::new();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Connection, provided by `mini-redis`, handles parsing frames from
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// the socket
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>connection<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Connection::new(socket);<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Use `read_frame` to receive a command from the connection.
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">while</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(frame)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>connection.read_frame().<span style="color:#080;font-weight:bold">await</span>.unwrap()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>response<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">match</span><span style="color:#bbb"> </span>Command::from_frame(frame).unwrap()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span>Set(cmd)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#888">// The value is stored as `Vec&lt;u8&gt;`
</span><span style="color:#888"></span><span style="color:#bbb">                </span>db.insert(cmd.key().to_string(),<span style="color:#bbb"> </span>cmd.value().to_vec());<span style="color:#bbb">
</span><span style="color:#bbb">                </span>Frame::Simple(<span style="background-color:#fff0f0">&#34;OK&#34;</span>.to_string())<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb">
</span><span style="color:#bbb">            </span>Get(cmd)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(value)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>db.get(cmd.key())<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                    </span><span style="color:#888">// `Frame::Bulk` expects data to be of type `Bytes`. This
</span><span style="color:#888"></span><span style="color:#bbb">                    </span><span style="color:#888">// type will be covered later in the tutorial. For now,
</span><span style="color:#888"></span><span style="color:#bbb">                    </span><span style="color:#888">// `&amp;Vec&lt;u8&gt;` is converted to `Bytes` using `into()`.
</span><span style="color:#888"></span><span style="color:#bbb">                    </span>Frame::Bulk(value.clone().into())<span style="color:#bbb">
</span><span style="color:#bbb">                </span>}<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">else</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                    </span>Frame::Null<span style="color:#bbb">
</span><span style="color:#bbb">                </span>}<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb">
</span><span style="color:#bbb">            </span>cmd<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>panic<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;unimplemented {:?}&#34;</span>,<span style="color:#bbb"> </span>cmd),<span style="color:#bbb">
</span><span style="color:#bbb">        </span>};<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Write the response to the client
</span><span style="color:#888"></span><span style="color:#bbb">        </span>connection.write_frame(<span style="color:#333">&amp;</span>response).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>现在我们运行这个server：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">cargo run
</code></pre></div><p>在另一个终端运行<code>hello-redis</code>程序：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">cargo run --example hello-redis
</code></pre></div><p>我们可以看到输出为：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">got value from the server; success=Some(b&#34;world&#34;)
</code></pre></div><p>我们现在可以插入和读取数据了，但是这里有个问题：数据并没有在连接之间共享，如果另一个客户端想要读取相同的键值，它什么都读不到。在下一节我们来看看如何把数据跨连接保存并共享。</p>
<h1 id="共享状态">共享状态</h1>
<h2 id="策略">策略</h2>
<p>有很多策略都能够在Tokio中共享状态：</p>
<ol>
<li>用互斥锁来保护状态变量。</li>
<li>发布一个专门用于管理状态的任务，使用消息传递模式来操作状态。</li>
</ol>
<p>一般来说第一种方法用来管理简单的数据，第二种用于需要异步操作的工作，如IO操作。在本节，我们需要共享的状态是一个哈希表，对应的操作是插入和查询（insert和get），这些操作都是同步的，因此我们使用互斥锁即可。第二种方法将在下一节讲述。</p>
<h2 id="添加bytes包">添加bytes包</h2>
<p>我们的Mini-Redis使用<code>Bytes</code>数据结构，而不是<code>Vec&lt;u8&gt;</code>来表示字节流，前者来自<code>bytes</code>包。<code>Bytes</code>的设计目标是为网络编程提供健壮的字节数组。它与<code>Vec&lt;u8&gt;</code>的最大区别是浅拷贝。也就是说，当我们在<code>Bytes</code>实例上调用<code>clone()</code>方法时，并不会拷贝内部的数据，实际上它仅仅增加引用计数。在实现上，你可以认为近似于<code>Arc&lt;Vec&lt;u8&gt;&gt;</code>，只不过提供了更丰富的封装。</p>
<p>我们在Cargo.toml里添加：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">bytes = &#34;0.6&#34;
</code></pre></div><h2 id="初始化hashmap">初始化HashMap</h2>
<p>我们的哈希表会在许多任务间共享，因此用<code>Arc&lt;Mutex&lt;_&gt;&gt;</code>来封装即可。</p>
<p>首先我们为这一类型起个别名：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>bytes::Bytes;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::collections::HashMap;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::sync::{Arc,<span style="color:#bbb"> </span>Mutex};<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">type</span> <span style="color:#b06;font-weight:bold">Db</span><span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Arc<span style="color:#333">&lt;</span>Mutex<span style="color:#333">&lt;</span>HashMap<span style="color:#333">&lt;</span><span style="color:#007020">String</span>,<span style="color:#bbb"> </span>Bytes<span style="color:#333">&gt;&gt;&gt;</span>;<span style="color:#bbb">
</span></code></pre></div><p>而后我们修改main函数进行初始化，将智能指针<code>Arc</code>传递给<code>process</code>函数，<code>Arc</code>是线程安全的引用计数指针。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpListener;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::collections::HashMap;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::sync::{Arc,<span style="color:#bbb"> </span>Mutex};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>listener<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>TcpListener::bind(<span style="background-color:#fff0f0">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;Listening&#34;</span>);<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>db<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Arc::new(Mutex::new(HashMap::new()));<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(socket,<span style="color:#bbb"> </span>_)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>listener.accept().<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Clone the handle to the hash map.
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>db<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>db.clone();<span style="color:#bbb">
</span><span style="color:#bbb">        </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;Accepted&#34;</span>);<span style="color:#bbb">
</span><span style="color:#bbb">        </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span>process(socket,<span style="color:#bbb"> </span>db).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span>});<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><h3 id="stdsyncmutex">std::sync::Mutex</h3>
<p>注意我们使用的是<code>std::sync::Mutex</code>而不是<code>tokio::sync::Mutex</code>。在同步的代码中使用<code>tokio::sync::Mutex</code>是错误的。异步的互斥锁是指其锁的范围跨越了<code>.await</code>操作符。</p>
<p>一个同步的互斥锁会使当前线程阻塞，等待获取锁，因此会使得当前线程无法再同时处理别的任务。使用<code>tokio::sync::Mutex</code>也并不会改变这种情况，因为异步的互斥锁在内部也是使用了原始的同步互斥锁。</p>
<p>通常的经验是，在异步代码块中使用同步互斥锁没啥问题，只要临界区很小并且锁不跨越<code>.await</code>。此外，你可以考虑使用<code>parking_lot::Mutex</code>，它比标准库的互斥锁更快一些。</p>
<h2 id="更新process函数">更新process函数</h2>
<p>process函数不再需要初始化哈希表了，它接收其实例的一个智能指针作为参数。在插入数据时，我们需要先加锁。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpStream;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::{Connection,<span style="color:#bbb"> </span>Frame};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">process</span>(socket: <span style="color:#b06;font-weight:bold">TcpStream</span>,<span style="color:#bbb"> </span>db: <span style="color:#b06;font-weight:bold">Db</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::Command::{self,<span style="color:#bbb"> </span>Get,<span style="color:#bbb"> </span>Set};<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Connection, provided by `mini-redis`, handles parsing frames from
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// the socket
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>connection<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Connection::new(socket);<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">while</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(frame)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>connection.read_frame().<span style="color:#080;font-weight:bold">await</span>.unwrap()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>response<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">match</span><span style="color:#bbb"> </span>Command::from_frame(frame).unwrap()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span>Set(cmd)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>db<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>db.lock().unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">                </span>db.insert(cmd.key().to_string(),<span style="color:#bbb"> </span>cmd.value().clone());<span style="color:#bbb">
</span><span style="color:#bbb">                </span>Frame::Simple(<span style="background-color:#fff0f0">&#34;OK&#34;</span>.to_string())<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb">           
</span><span style="color:#bbb">            </span>Get(cmd)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>db<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>db.lock().unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(value)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>db.get(cmd.key())<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                    </span>Frame::Bulk(value.clone())<span style="color:#bbb">
</span><span style="color:#bbb">                </span>}<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">else</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                    </span>Frame::Null<span style="color:#bbb">
</span><span style="color:#bbb">                </span>}<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb">
</span><span style="color:#bbb">            </span>cmd<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>panic<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;unimplemented {:?}&#34;</span>,<span style="color:#bbb"> </span>cmd),<span style="color:#bbb">
</span><span style="color:#bbb">        </span>};<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Write the response to the client
</span><span style="color:#888"></span><span style="color:#bbb">        </span>connection.write_frame(<span style="color:#333">&amp;</span>response).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><h2 id="任务线程以及竞争">任务，线程以及竞争</h2>
<p>使用阻塞的互斥锁来保护短的临界区是很好的策略，尤其是竞争较小的情况。当锁被争用的时候，线程必须阻塞并且等待锁释放，这同时也导致当前线程被分配的其他任务也被阻塞。</p>
<p>默认情况下，Tokio运行时使用多线程的调度器。任务将在多个线程组成的线程池中调度执行。如果大量任务被发布并执行在不同线程中，且都需要获得哈希表的锁，那么就产生了竞争。换句话说，如果配置了<code>current_thread</code>，锁就不会被竞争。</p>
<blockquote>
<p><code>current_thread</code>运行时是一个轻量级，单线程的运行时。当我们发布的任务不是很多，且连接数也不多的情况下，单线程是很好的思路。</p>
</blockquote>
<p>如果锁的争用很剧烈，影响程序的性能，可以考虑下面的一些选项：</p>
<ul>
<li>使用专门的Task来管理状态，用消息传递模式。</li>
<li>把锁分片。</li>
<li>重构代码，不用互斥锁。</li>
</ul>
<p>在我们的例子中，因为哈希表中每个key都是独立的，锁分片是很好的策略，我们不使用单独的<code>Mutex&lt;HashMap&lt;_, _&gt;&gt;</code>，而是使用<code>N</code>个哈希表实例：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">type</span> <span style="color:#b06;font-weight:bold">ShardedDb</span><span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Arc<span style="color:#333">&lt;</span><span style="color:#007020">Vec</span><span style="color:#333">&lt;</span>Mutex<span style="color:#333">&lt;</span>HashMap<span style="color:#333">&lt;</span><span style="color:#007020">String</span>,<span style="color:#bbb"> </span><span style="color:#007020">Vec</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">u8</span><span style="color:#333">&gt;&gt;&gt;&gt;&gt;</span>;<span style="color:#bbb">
</span></code></pre></div><p>而后，寻找相应<code>key</code>所在的位置分两步：首先，利用哈希值确定key所在的哈希表，然后再查该哈希表。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>shard<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>db[hash(key)<span style="color:#bbb"> </span><span style="color:#333">%</span><span style="color:#bbb"> </span>db.len()].lock().unwrap();<span style="color:#bbb">
</span><span style="color:#bbb"></span>shard.insert(key,<span style="color:#bbb"> </span>value);<span style="color:#bbb">
</span></code></pre></div><p><a href="https://docs.rs/dashmap" target="_blank">dashmap</a>包基于这一思想实现了分片的哈希表，提供更好的并发性能。</p>
<h2 id="跨await的锁">跨.await的锁</h2>
<p>你可能会写出如下的代码：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::sync::Mutex;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">increment_and_do_stuff</span>(mutex: <span style="color:#038;font-weight:bold">&amp;</span><span style="color:#b06;font-weight:bold">Mutex</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">i32</span><span style="color:#333">&gt;</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>lock<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>mutex.lock().unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#333">*</span>lock<span style="color:#bbb"> </span><span style="color:#333">+=</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">1</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>do_something_async().<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb"> </span><span style="color:#888">// lock goes out of scope here
</span></code></pre></div><p>当你在Tokio任务中调用这一函数时，编译会报错：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">error: future cannot be sent between threads safely
   --&gt; src/lib.rs:13:5
    |
13  |     tokio::spawn(async move {
    |     ^^^^^^^^^^^^ future created by async block is not `Send`
    |
   ::: /playground/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-0.2.21/src/task/spawn.rs:127:21
    |
127 |         T: Future + Send + &#39;static,
    |                     ---- required by this bound in `tokio::task::spawn::spawn`
    |
    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard&lt;&#39;_, i32&gt;`
note: future is not `Send` as this value is used across an await
   --&gt; src/lib.rs:7:5
    |
4   |     let mut lock = mutex.lock().unwrap();
    |         -------- has type `std::sync::MutexGuard&lt;&#39;_, i32&gt;` which is not `Send`
...
7   |     do_something_async().await;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ await occurs here, with `mut lock` maybe used later
8   | }
    | - `mut lock` is later dropped here
</code></pre></div><p>错误原因是，<code>std::sync:MutexGuard</code>不是<code>Send</code>的。这意味着你不能让一个互斥锁跨线程传递。前面说过，Tokio调度器可能会让一个任务在多个线程上执行。为了解决这个问题，你必须要在<code>.await</code>之前释放锁：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#888">// This works!
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">increment_and_do_stuff</span>(mutex: <span style="color:#038;font-weight:bold">&amp;</span><span style="color:#b06;font-weight:bold">Mutex</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">i32</span><span style="color:#333">&gt;</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>lock<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>mutex.lock().unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#333">*</span>lock<span style="color:#bbb"> </span><span style="color:#333">+=</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">1</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb"> </span><span style="color:#888">// lock goes out of scope here
</span><span style="color:#888"></span><span style="color:#bbb">    </span>do_something_async().<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>注意，虽然看起来很对，但是下面这段代码无法通过编译：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::sync::Mutex;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#888">// This fails too.
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">increment_and_do_stuff</span>(mutex: <span style="color:#038;font-weight:bold">&amp;</span><span style="color:#b06;font-weight:bold">Mutex</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">i32</span><span style="color:#333">&gt;</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>lock<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>mutex.lock().unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#333">*</span>lock<span style="color:#bbb"> </span><span style="color:#333">+=</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">1</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>drop(lock);<span style="color:#bbb">
</span><span style="color:#bbb">    </span>do_something_async().<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>这是因为编译器目前仅根据作用域来判断一个<code>future</code>是否是<code>Send</code>的。将来可能会支持显式的<code>drop</code>，不过现在还是老老实实用大括号吧。</p>
<p>不要想着能不能在不要求<code>Send</code>的情况下发布任务来躲避这一问题（单线程调度器）。因为如果Tokio在await时挂起了你的任务，但锁还未释放，另一个任务可能会在同一线程执行，并请求同一个锁。此时就产生了死锁，因为当前线程阻塞，但是锁永远无法释放。</p>
<h3 id="其他办法">其他办法</h3>
<p>在await前通过作用域释放锁是一个办法，实际上还有更鲁棒的写法。例如，你可以把互斥锁包装在一个结构体中，然后通过一个方法来执行锁的逻辑。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::sync::Mutex;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">CanIncrement</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>mutex: <span style="color:#b06;font-weight:bold">Mutex</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">i32</span><span style="color:#333">&gt;</span>,<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">impl</span><span style="color:#bbb"> </span>CanIncrement<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// This function is not marked async.
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">increment</span>(<span style="color:#333">&amp;</span>self)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>lock<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>self.mutex.lock().unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#333">*</span>lock<span style="color:#bbb"> </span><span style="color:#333">+=</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">1</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">increment_and_do_stuff</span>(can_incr: <span style="color:#038;font-weight:bold">&amp;</span><span style="color:#b06;font-weight:bold">CanIncrement</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>can_incr.increment();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>do_something_async().<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>这一编程模式保证了上面的<code>Send</code>错误永远不会出现，因为锁根本就没有出现在异步块中。</p>
<p>另一个办法就是使用消息传递策略，我们将在下一节提到。</p>
<h3 id="tokio的异步锁">Tokio的异步锁</h3>
<p>我们前面提到的<code>tokio::sync::Mutex</code>终于派上用场了。它最主要的特性就是能够跨越<code>.await</code>，而不产生问题。当然这也意味着异步锁的性能损失更大，如果非必要，请用上面的两种策略，而不是用异步锁：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::sync::Mutex;<span style="color:#bbb"> </span><span style="color:#888">// note! This uses the Tokio mutex
</span><span style="color:#888">// This compiles!
</span><span style="color:#888">// (but restructuring the code would be better in this case)
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">increment_and_do_stuff</span>(mutex: <span style="color:#038;font-weight:bold">&amp;</span><span style="color:#b06;font-weight:bold">Mutex</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">i32</span><span style="color:#333">&gt;</span>)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>lock<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>mutex.lock().<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#333">*</span>lock<span style="color:#bbb"> </span><span style="color:#333">+=</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">1</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>do_something_async().<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb"> </span><span style="color:#888">// lock goes out of scope here
</span></code></pre></div><h1 id="channels">Channels</h1>
<p>现在我们已经学到了一些Tokio的异步知识了，本节我们来写写客户端。首先我们尝试发布Tokio任务来发送命令：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::client;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Establish a connection to the server
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>client<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>client::connect(<span style="background-color:#fff0f0">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Spawn two tasks, one gets a key, the other sets a key
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>t1<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>res<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>client.get(<span style="background-color:#fff0f0">&#34;hello&#34;</span>).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>});<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>t2<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>client.set(<span style="background-color:#fff0f0">&#34;foo&#34;</span>,<span style="color:#bbb"> </span><span style="background-color:#fff0f0">&#34;bar&#34;</span>.into()).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>});<span style="color:#bbb">
</span><span style="color:#bbb">    </span>t1.<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span>t2.<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>上面这段代码并不能通过编译，因为两个任务都需要用到client变量，但是<code>Client</code>并没有实现<code>Copy</code>，因此这一共享是错误的。当然我们可以为每条命令都新建一个连接，但显然这很慢。</p>
<h2 id="消息传递">消息传递</h2>
<p>答案是使用消息传递模型，即我们使用专门的任务来管理<code>client</code>连接。任何想要发送新的命令的任务都把指令作为一条消息传递给该client任务，client任务负责把命令发送给服务端，然后再把消息传回原任务。</p>
<p>使用这一策略，我们只需要维护一个与服务端的连接即可。client任务能够很好地处理收到的命令，同时channel本身也起到缓冲的作用。此模型很好地提高吞吐量，同时也可以扩展成连接池模型。</p>
<h2 id="tokio的channel原语">Tokio的channel原语</h2>
<p>Tokio提供了许多类型的channel，每一个都提供不同的功能和设计目标：</p>
<ul>
<li><a href="https://docs.rs/tokio/0.3/tokio/sync/mpsc/index.html" target="_blank">mpsc</a>：多生产者，单消费者。可以一次传递多个值。</li>
<li><a href="https://docs.rs/tokio/0.3/tokio/sync/oneshot/index.html" target="_blank">oneshot</a>：单生产者，单消费者。一次只能传递一个值。</li>
<li><a href="https://docs.rs/tokio/0.3/tokio/sync/broadcast/index.html" target="_blank">broadcast</a>：多生产者，多消费者。一次传递多值，值能够被每个接收器看见。</li>
<li><a href="https://docs.rs/tokio/0.3/tokio/sync/watch/index.html" target="_blank">watch</a>：单生产者，多消费者。一次传递多值，不过不记录消息历史。接收器只能看见最近的值。</li>
</ul>
<p>如果你需要多生产者，多消费者的channel，并且只有一个接收器能看见全部值，你可以使用<a href="https://docs.rs/async-channel/" target="_blank">async-channel</a>包。在同步编程中也有一些channel，如std::sync::mpsc和<a href="https://docs.rs/crossbeam/latest/crossbeam/channel/index.html" target="_blank">crossbeam::channel</a>，这些channel在等待数据的时候会阻塞当前线程，而在Tokio异步编程中，当前线程不会阻塞。</p>
<p>在本节，我们会使用<code>mpsc</code>和<code>oneshot</code>，另外几种channel将在后续讲解。</p>
<h2 id="定义消息类型">定义消息类型</h2>
<p>在大多数情况下，当我们使用消息传递时，接收消息的任务常常需要响应多个累积的消息。在我们的例子中，该任务需要处理<code>GET</code>和<code>SET</code>消息，我们首先定义<code>Command</code>类型：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>bytes::Bytes;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[derive(Debug)]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">enum</span> <span style="color:#b06;font-weight:bold">Command</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Get<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>key: <span style="color:#007020">String</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Set<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>key: <span style="color:#007020">String</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>val: <span style="color:#b06;font-weight:bold">Bytes</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><h2 id="创建channel">创建channel</h2>
<p>在main函数中，我们以如下方式创建<code>mpsc</code>通道：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::sync::mpsc;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Create a new channel with a capacity of at most 32.
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(<span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>tx,<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>rx)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>mpsc::channel(<span style="color:#00d;font-weight:bold">32</span>);<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// ... Rest comes here
</span><span style="color:#888"></span>}<span style="color:#bbb">
</span></code></pre></div><p>这个channel是为了向管理连接的任务发送命令的，多生产者属性使得我们可以在多个任务中发送消息。tx和rx分别是channel的发送器和接收器句柄，它们可以被分配给不同的任务。</p>
<p>当前channel以容量32创建，如果消息的发送速度大于接受速度，则通道会保存未读取的数据。一旦通道中保存的数据超过32，调用<code>send(...).await</code>会导致任务挂起，直到channel有多余空间。</p>
<p>从多个任务发送数据可以通过克隆Sender来实现，例如：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::sync::mpsc;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(<span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>tx,<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>rx)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>mpsc::channel(<span style="color:#00d;font-weight:bold">32</span>);<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>tx2<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tx.clone();<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>tx.send(<span style="background-color:#fff0f0">&#34;sending from first handle&#34;</span>).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>});<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>tx2.send(<span style="background-color:#fff0f0">&#34;sending from second handle&#34;</span>).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>});<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">while</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(message)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>rx.recv().<span style="color:#080;font-weight:bold">await</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;GOT = {}&#34;</span>,<span style="color:#bbb"> </span>message);<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>在上面的代码中，两个数据都被发送到了Reciever，注意mpsc的接收器是无法复制的。</p>
<p>当每个Sender实例都结束生命期后，这就意味着我们无法再向对应的接收器发送任何数据。此时，如果对rx调用recv会得到None，这代表着所有Sender都已经释放，因此channel关闭。</p>
<p>在mini-redis项目中，管理客户端连接的任务将在channel关闭的同时关闭对应的TCP连接，因为不会再有新的命令了，此redis连接作废。</p>
<h2 id="创建manager">创建manager</h2>
<p>现在我们创建一个新的任务，用以管理channel的数据接收和发送。首先，我们建立一个新的与Redis服务的TCP连接，之后我们把从channel中接收到的数据转发到Redis即可。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::client;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#888">// The `move` keyword is used to **move** ownership of `rx` into the task.
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>manager<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Establish a connection to the server
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>client<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>client::connect(<span style="background-color:#fff0f0">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Start receiving messages
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">while</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(cmd)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>rx.recv().<span style="color:#080;font-weight:bold">await</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>Command::<span style="color:#333">*</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">match</span><span style="color:#bbb"> </span>cmd<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span>Get<span style="color:#bbb"> </span>{<span style="color:#bbb"> </span>key<span style="color:#bbb"> </span>}<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span>client.get(<span style="color:#333">&amp;</span>key).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb">
</span><span style="color:#bbb">            </span>Set<span style="color:#bbb"> </span>{<span style="color:#bbb"> </span>key,<span style="color:#bbb"> </span>val<span style="color:#bbb"> </span>}<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span>client.set(<span style="color:#333">&amp;</span>key,<span style="color:#bbb"> </span>val).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>});<span style="color:#bbb">
</span></code></pre></div><p>现在我们把上一小节的代码修改一下，把数据发送给manager，而不是Redis服务器：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#888">// The `Sender` handles are moved into the tasks. As there are two
</span><span style="color:#888">// tasks, we need a second `Sender`.
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>tx2<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tx.clone();<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#888">// Spawn two tasks, one gets a key, the other sets a key
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>t1<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>cmd<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Command::Get<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>key: <span style="background-color:#fff0f0">&#34;hello&#34;</span>.to_string(),<span style="color:#bbb">
</span><span style="color:#bbb">    </span>};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>tx.send(cmd).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb"></span>});<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>t2<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>cmd<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Command::Set<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>key: <span style="background-color:#fff0f0">&#34;foo&#34;</span>.to_string(),<span style="color:#bbb">
</span><span style="color:#bbb">        </span>val: <span style="background-color:#fff0f0">&#34;bar&#34;</span>.into(),<span style="color:#bbb">
</span><span style="color:#bbb">    </span>};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>tx2.send(cmd).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb"></span>});<span style="color:#bbb">
</span></code></pre></div><p>在main函数的结尾我们await三个任务的<code>JoinHandle</code>，以保证它们都执行完成：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">t1.<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb"></span>t2.<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb"></span>manager.<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span></code></pre></div><h2 id="接收响应">接收响应</h2>
<p>最后一步，我们还要把Redis服务器返回的响应内容转发到发送命令的task。<code>GET</code>命令需要获得具体的值，而<code>SET</code>命令需要返回操作结果（失败or成功）。</p>
<p>为了把response传回去，我们使用前面介绍的<code>oneshot</code>通道。它是单生产者，单消费者，并且为单值的消息传递作了优化。在我们的例子中，单值指的是Response。</p>
<p>类似于<code>mpsc</code>，<code>oneshot::channel</code>返回发送器和接收器句柄：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::sync::oneshot;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(tx,<span style="color:#bbb"> </span>rx)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>oneshot::channel();<span style="color:#bbb">
</span></code></pre></div><p>不过和mpsc不同，我们不需要设置channel的大小，并且任何一个句柄都是不可复制的。</p>
<p>为了从manager协程接收到响应，在发送命令之前，我们需要先创建一个oneshot通道，然后把发送器一起传给manager即可。为此我们更新一下之前定义的<code>Command</code>类型：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::sync::oneshot;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>bytes::Bytes;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#d42;background-color:#fff0f0">/// Multiple different commands are multiplexed over a single channel.
</span><span style="color:#d42;background-color:#fff0f0"></span><span style="color:#579">#[derive(Debug)]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">enum</span> <span style="color:#b06;font-weight:bold">Command</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Get<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>key: <span style="color:#007020">String</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>resp: <span style="color:#b06;font-weight:bold">Responder</span><span style="color:#333">&lt;</span><span style="color:#007020">Option</span><span style="color:#333">&lt;</span>Bytes<span style="color:#333">&gt;&gt;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Set<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>key: <span style="color:#007020">String</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>val: <span style="color:#007020">Vec</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">u8</span><span style="color:#333">&gt;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>resp: <span style="color:#b06;font-weight:bold">Responder</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#d42;background-color:#fff0f0">/// Provided by the requester and used by the manager task to send
</span><span style="color:#d42;background-color:#fff0f0">/// the command response back to the requester.
</span><span style="color:#d42;background-color:#fff0f0"></span><span style="color:#080;font-weight:bold">type</span> <span style="color:#b06;font-weight:bold">Responder</span><span style="color:#333">&lt;</span>T<span style="color:#333">&gt;</span><span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>oneshot::Sender<span style="color:#333">&lt;</span>mini_redis::<span style="color:#007020">Result</span><span style="color:#333">&lt;</span>T<span style="color:#333">&gt;&gt;</span>;<span style="color:#bbb">
</span></code></pre></div><p>现在我们更新之前的两个发送任务：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>t1<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(resp_tx,<span style="color:#bbb"> </span>resp_rx)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>oneshot::channel();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>cmd<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Command::Get<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>key: <span style="background-color:#fff0f0">&#34;hello&#34;</span>.to_string(),<span style="color:#bbb">
</span><span style="color:#bbb">        </span>resp: <span style="color:#b06;font-weight:bold">resp_tx</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>};<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Send the GET request
</span><span style="color:#888"></span><span style="color:#bbb">    </span>tx.send(cmd).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Await the response
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>res<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>resp_rx.<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;GOT = {:?}&#34;</span>,<span style="color:#bbb"> </span>res);<span style="color:#bbb">
</span><span style="color:#bbb"></span>});<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>t2<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(resp_tx,<span style="color:#bbb"> </span>resp_rx)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>oneshot::channel();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>cmd<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Command::Set<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>key: <span style="background-color:#fff0f0">&#34;foo&#34;</span>.to_string(),<span style="color:#bbb">
</span><span style="color:#bbb">        </span>val: <span style="color:#b06;font-weight:bold">b</span><span style="background-color:#fff0f0">&#34;bar&#34;</span>.to_vec(),<span style="color:#bbb">
</span><span style="color:#bbb">        </span>resp: <span style="color:#b06;font-weight:bold">resp_tx</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>};<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Send the SET request
</span><span style="color:#888"></span><span style="color:#bbb">    </span>tx2.send(cmd).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Await the response
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>res<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>resp_rx.<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;GOT = {:?}&#34;</span>,<span style="color:#bbb"> </span>res);<span style="color:#bbb">
</span><span style="color:#bbb"></span>});<span style="color:#bbb">
</span></code></pre></div><p>最后再修改一下manager任务，让它把接收到的响应通过Sender发送回去：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">while</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(cmd)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>rx.recv().<span style="color:#080;font-weight:bold">await</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">match</span><span style="color:#bbb"> </span>cmd<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>Command::Get<span style="color:#bbb"> </span>{<span style="color:#bbb"> </span>key,<span style="color:#bbb"> </span>resp<span style="color:#bbb"> </span>}<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>res<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>client.get(<span style="color:#333">&amp;</span>key).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Ignore errors
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>_<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>resp.send(res);<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span>Command::Set<span style="color:#bbb"> </span>{<span style="color:#bbb"> </span>key,<span style="color:#bbb"> </span>val,<span style="color:#bbb"> </span>resp<span style="color:#bbb"> </span>}<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>res<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>client.set(<span style="color:#333">&amp;</span>key,<span style="color:#bbb"> </span>val.into()).<span style="color:#080;font-weight:bold">await</span>;<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Ignore errors
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>_<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>resp.send(res);<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>注意，调用oneshot通道的send是一个同步方法，不需要await。这是因为oneshot的send会立刻知道是否发送成功。当接收器实例已经释放，则send会返回<code>Err</code>，在上面的代码中，我们忽略这一错误，因为这是允许的情况。</p>
<h2 id="背压以及有界channel">背压以及有界channel</h2>
<p>当并发和队列同时出现，我们需要保证队列是有界的，并且系统能够优雅地处理负载。无界地队列最终有可能会占满整个内存，导致系统出现不可预知的错误。</p>
<p>Tokio防止隐式的队列出现。很大一部分原因是异步操作是惰性的，例如下面的代码：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>async_op();<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>如果异步操作是立刻执行的，那么上面的循环会不断地创建新的异步操作，而不会等待上一个操作执行完成，这就产生了隐式的无界队列。基于回调的系统，以及基于eager future的系统特别容易出现这样的错误。</p>
<p>然而，异步Rust和Tokio很好地规避了这一问题，上面的代码在Rust中不会直接执行，async_op本身只是一个Future变量，只有调用await才能让它真正执行，否则就只是一个单纯的死循环，不会占用更多内存。</p>
<p>并发和队列必须显式调用，比如通过如下形式：</p>
<ul>
<li><code>tokio::spawn</code></li>
<li><code>select!</code></li>
<li><code>join!</code></li>
<li><code>mpsc::channel</code></li>
</ul>
<p>当我们做这些调用的时候，请保证所有的并发任务数目是有界的。例如，当编写异步接收TCP请求的循环时，请保证socket的数量是有界的；当使用mpsc通道时，设置一个适当的channel容量，容量大小取决于具体应用的特性。</p>
<p>小心地选取适当的bound是编写可靠的Tokio应用程序的重要一步。</p>
<h1 id="io">I/O</h1>
<p>Tokio里面的I/O操作和标准库里的很像，只不过全部进行了异步化。我们使用两个trait来实现：<code>AsyncRead</code>和<code>AsyncWrite</code>。一些常用的类型都实现了这两种trait，例如<code>TcpStream</code>，<code>File</code>，<code>Stdout</code>。一些常用的数据结构也实现了，如<code>Vec&lt;u8&gt;</code>和<code>&amp;[u8]</code>。</p>
<p>本节将介绍基本的Tokio I/O编程，下一节将介绍更高级的用法。</p>
<h2 id="asyncread和asyncwrite">AsyncRead和AsyncWrite</h2>
<p>这两个trait提供了异步读写字节流的功能，其内部方法实际上不会手动调用，而是通过Tokio提供的工具包<code>AsyncReadExt</code>和<code>AsyncWriteExt</code>来调用。</p>
<p>我们简单看看这些工具包里的方法，注意所有的方法都是异步的，需要使用await才能实际执行。</p>
<h3 id="async-fn-read"><code>async fn read()</code></h3>
<p><code>AsyncReadExt::read()</code>提供了异步读取数据到一个buffer的能力，返回读取到的字节数。</p>
<p><strong>注意</strong>：当<code>read()</code>返回<code>Ok(0)</code>时，说明流已经关闭了，任何后续的读取都会返回0。因此如果读写的是TcpStream，我们可以直接关闭连接了（实际上此时说明TCP连接的对方已经调用close关闭连接，发送了FIN报文）。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::fs::File;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::io::{self,<span style="color:#bbb"> </span>AsyncReadExt};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">io</span>::<span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>f<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>File::open(<span style="background-color:#fff0f0">&#34;foo.txt&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buffer<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>[<span style="color:#00d;font-weight:bold">0</span>;<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">10</span>];<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// read up to 10 bytes
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>n<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>f.read(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buffer[..]).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;The bytes: {:?}&#34;</span>,<span style="color:#bbb"> </span><span style="color:#333">&amp;</span>buffer[..n]);<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#007020">Ok</span>(())<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><h3 id="async-fn-read_to_end"><code>async fn read_to_end()</code></h3>
<p><code>AsyncReadExt::read_to_end</code>将从流中读取所有字节，直到遇到EOF。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::io::{self,<span style="color:#bbb"> </span>AsyncReadExt};<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::fs::File;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">io</span>::<span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>f<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>File::open(<span style="background-color:#fff0f0">&#34;foo.txt&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buffer<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span><span style="color:#007020">Vec</span>::new();<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// read the whole file
</span><span style="color:#888"></span><span style="color:#bbb">    </span>f.read_to_end(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buffer).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#007020">Ok</span>(())<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><h3 id="async-fn-write"><code>async fn write()</code></h3>
<p><code>AsyncWriteExt::write</code>将一个buffer里面的所有字节都写到流中（不一定能全部写进去），返回实际写入的字节数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::io::{self,<span style="color:#bbb"> </span>AsyncWriteExt};<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::fs::File;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">io</span>::<span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>file<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>File::create(<span style="background-color:#fff0f0">&#34;foo.txt&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Writes some prefix of the byte string, but not necessarily all of it.
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>n<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>file.write(<span style="background-color:#fff0f0">b&#34;some bytes&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;Wrote the first {} bytes of &#39;some bytes&#39;.&#34;</span>,<span style="color:#bbb"> </span>n);<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#007020">Ok</span>(())<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><h3 id="async-fn-write_all"><code>async fn write_all()</code></h3>
<p><code>AsyncWriteExt::write_all</code>把整个buffer中的数据全部写入，保证全部写入完成才会返回。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::io::{self,<span style="color:#bbb"> </span>AsyncWriteExt};<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::fs::File;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">io</span>::<span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buffer<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>File::create(<span style="background-color:#fff0f0">&#34;foo.txt&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>buffer.write_all(<span style="background-color:#fff0f0">b&#34;some bytes&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#007020">Ok</span>(())<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>除此之外还有很多其他实用的函数可以查看API文档。</p>
<h2 id="helper函数">Helper函数</h2>
<p>和标准库std一样，<code>tokio::io</code>模块包含很多实用的工具函数，例如<code>tokio::io::copy</code>异步地将一个reader的数据拷贝到一个writer发送出去。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::fs::File;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::io;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">io</span>::<span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>reader: <span style="color:#038;font-weight:bold">&amp;</span>[<span style="color:#339;font-weight:bold">u8</span>]<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span><span style="background-color:#fff0f0">b&#34;hello&#34;</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>file<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>File::create(<span style="background-color:#fff0f0">&#34;foo.txt&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>io::copy(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>reader,<span style="color:#bbb"> </span><span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>file).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#007020">Ok</span>(())<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>当然这利用了一个事实：字节数组<code>&amp;[u8]</code>实现了<code>AsyncRead</code>。</p>
<h2 id="echo服务器">Echo服务器</h2>
<p>回响服务器是常见的网络编程例子，我们来实现一下。首先需要创建一个<code>TcpListener</code>，接收到来的客户端请求，每个连接的处理都是一致的：从socket中读取数据，然后直接将读取到的数据写回。因此客户端看到的响应就是自己之前发送的数据。</p>
<p>我们将用两种不太一样的策略来实现echo服务器。</p>
<h3 id="使用iocopy实现">使用<code>io::copy</code>实现</h3>
<p>我们首先利用前面介绍的<code>io::copy</code>方法来实现，大致的框架先搭好：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::io;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpListener;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">io</span>::<span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>listener<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>TcpListener::bind(<span style="background-color:#fff0f0">&#34;127.0.0.1:6142&#34;</span>).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(<span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>socket,<span style="color:#bbb"> </span>_)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>listener.accept().<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Copy data here
</span><span style="color:#888"></span><span style="color:#bbb">        </span>});<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>显然我们只需要在空出来的异步块中填写copy的逻辑即可，注意到<code>TcpStream</code>同时实现了<code>AsyncRead</code>和<code>AsyncWrite</code>，是不是可以直接作为reader和writer调用copy呢？</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#888">// This fails to compile
</span><span style="color:#888"></span>io::copy(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>socket,<span style="color:#bbb"> </span><span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>socket).<span style="color:#080;font-weight:bold">await</span><span style="color:#bbb">
</span></code></pre></div><p>很遗憾上面的代码无法编译，因为我们同时可变引用了两次<code>socket</code>变量（<code>&amp;mut</code>），这在Rust中是不允许的。</p>
<h4 id="拆分成reader和writer">拆分成reader和writer</h4>
<p>如何处理这个问题呢，我们把一个socket拆分成用于reader的句柄和用于writer的句柄。任何同时具有reader和writer属性的类型都可以使用<code>io::aplit</code>拆分，此函数返回reader和writer句柄，而后这两个句柄可以单独用于不同的任务。</p>
<p>例如我们的echo客户端可以如下编写：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::io::{self,<span style="color:#bbb"> </span>AsyncReadExt,<span style="color:#bbb"> </span>AsyncWriteExt};<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpStream;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">io</span>::<span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>socket<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>TcpStream::connect(<span style="background-color:#fff0f0">&#34;127.0.0.1:6142&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(<span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>rd,<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>wr)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>io::split(socket);<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Write data in the background
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>write_task<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>wr.write_all(<span style="background-color:#fff0f0">b&#34;hello</span><span style="color:#666;background-color:#fff0f0;font-weight:bold">\r\n</span><span style="background-color:#fff0f0">&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span>wr.write_all(<span style="background-color:#fff0f0">b&#34;world</span><span style="color:#666;background-color:#fff0f0;font-weight:bold">\r\n</span><span style="background-color:#fff0f0">&#34;</span>).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Sometimes, the rust type inferencer needs
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// a little help
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#007020">Ok</span>::<span style="color:#333">&lt;</span>_,<span style="color:#bbb"> </span>io::Error<span style="color:#333">&gt;</span>(())<span style="color:#bbb">
</span><span style="color:#bbb">    </span>});<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buf<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>vec<span style="color:#333">!</span>[<span style="color:#00d;font-weight:bold">0</span>;<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">128</span>];<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>n<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>rd.read(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buf).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span>n<span style="color:#bbb"> </span><span style="color:#333">==</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">0</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">break</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span>println<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;GOT {:?}&#34;</span>,<span style="color:#bbb"> </span><span style="color:#333">&amp;</span>buf[..n]);<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#007020">Ok</span>(())<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p><code>io::split</code>支持任何实现了<code>AsyncWrite+AsyncRead</code>的类型，在内部它使用<code>Arc</code>和<code>Mutex</code>，这会产生一定的性能损失。对于<code>TcpStream</code>，我们提供了独特的<code>split</code>机制。</p>
<p><code>TcpStream::split</code>接收一个stream的引用作为参数，然会读写句柄。由于我们使用的是引用，因此得到的两个读写句柄不能再用在别的task上了，只能用于当前任务。这个特殊的<code>split</code>函数是零开销的，内部没有使用<code>Arc</code>和<code>Mutex</code>。<code>TcpStream</code>还提供了<code>into_split</code>方法，其提供了可以传递给其他任务的handle，里面用到了<code>Arc</code>。</p>
<p>由于<code>io::copy</code>是在同一task中调用的，我们可以直接使用<code>TcpStream::split</code>来实现拷贝的逻辑：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(<span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>rd,<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>wr)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>socket.split();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span>io::copy(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>rd,<span style="color:#bbb"> </span><span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>wr).<span style="color:#080;font-weight:bold">await</span>.is_err()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>eprintln<span style="color:#333">!</span>(<span style="background-color:#fff0f0">&#34;failed to copy&#34;</span>);<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>});<span style="color:#bbb">
</span></code></pre></div><h3 id="手动copy">手动copy</h3>
<p>现在我们考虑不用Tokio提供的工具，手动使用<code>read</code>和<code>write_all</code>来实现echo服务。代码如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::io::{self,<span style="color:#bbb"> </span>AsyncReadExt,<span style="color:#bbb"> </span>AsyncWriteExt};<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpListener;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#579">#[tokio::main]</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">io</span>::<span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>listener<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>TcpListener::bind(<span style="background-color:#fff0f0">&#34;127.0.0.1:6142&#34;</span>).<span style="color:#080;font-weight:bold">await</span>.unwrap();<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>(<span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>socket,<span style="color:#bbb"> </span>_)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>listener.accept().<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span>tokio::spawn(<span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">move</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buf<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>vec<span style="color:#333">!</span>[<span style="color:#00d;font-weight:bold">0</span>;<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">1024</span>];<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#080;font-weight:bold">match</span><span style="color:#bbb"> </span>socket.read(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buf).<span style="color:#080;font-weight:bold">await</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                    </span><span style="color:#888">// Return value of `Ok(0)` signifies that the remote has
</span><span style="color:#888"></span><span style="color:#bbb">                    </span><span style="color:#888">// closed
</span><span style="color:#888"></span><span style="color:#bbb">                    </span><span style="color:#007020">Ok</span>(<span style="color:#00d;font-weight:bold">0</span>)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">return</span>,<span style="color:#bbb">
</span><span style="color:#bbb">                    </span><span style="color:#007020">Ok</span>(n)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                        </span><span style="color:#888">// Copy the data back to socket
</span><span style="color:#888"></span><span style="color:#bbb">                        </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span>socket.write_all(<span style="color:#333">&amp;</span>buf[..n]).<span style="color:#080;font-weight:bold">await</span>.is_err()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                            </span><span style="color:#888">// Unexpected socket error. There isn&#39;t much we can
</span><span style="color:#888"></span><span style="color:#bbb">                            </span><span style="color:#888">// do here so just stop processing.
</span><span style="color:#888"></span><span style="color:#bbb">                            </span><span style="color:#080;font-weight:bold">return</span>;<span style="color:#bbb">
</span><span style="color:#bbb">                        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">                    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">                    </span><span style="color:#007020">Err</span>(_)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                        </span><span style="color:#888">// Unexpected socket error. There isn&#39;t much we can do
</span><span style="color:#888"></span><span style="color:#bbb">                        </span><span style="color:#888">// here so just stop processing.
</span><span style="color:#888"></span><span style="color:#bbb">                        </span><span style="color:#080;font-weight:bold">return</span>;<span style="color:#bbb">
</span><span style="color:#bbb">                    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">                </span>}<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span>});<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>我们一步步分析一下上面的代码。首先，创建一个大小为1024的buffer。注意我们使用的是<code>Vec</code>，堆上的动态数组，而不是栈上的基础数组<code>[u8]</code>。因为buffer的使用跨越了await，如果用栈数组来表示buffer，理论上也没问题，但由于它是栈上空间，我们每次处理一个请求都会开启新的一个task，每个task具有一个数据结构，看起来可能像这样：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Task</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// internal task fields here
</span><span style="color:#888"></span><span style="color:#bbb">    </span>task: <span style="color:#b06;font-weight:bold">enum</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>AwaitingRead<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span>socket: <span style="color:#b06;font-weight:bold">TcpStream</span>,<span style="color:#bbb">
</span><span style="color:#bbb">            </span>buf: [BufferType],<span style="color:#bbb">
</span><span style="color:#bbb">        </span>},<span style="color:#bbb">
</span><span style="color:#bbb">        </span>AwaitingWriteAll<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span>socket: <span style="color:#b06;font-weight:bold">TcpStream</span>,<span style="color:#bbb">
</span><span style="color:#bbb">            </span>buf: [BufferType],<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>如果使用栈数组，它将直接存放在task结构体中，这会导致结构体比较大，而且由于buffer的大小通常设为页的整数倍，这导致task结构的大小有点尴尬。因此，我们推荐使用堆上内存去分配buffer。</p>
<p>当TCP数据流关闭后，我们将从read中读到<code>Ok(0)</code>，此时必须跳出循环，因为后续的读取都会是这个，不跳出的话程序就一定会陷入死循环。</p>
<h1 id="framing">Framing</h1>
<p>我们现在可以应用前面的IO知识实现Mini-Redis的framing层（也叫解码层），指的是将字节流中的数据转化为数据帧的流，一个帧是客户端和服务端数据传输的一个单位。我们使用的Redis通信协议的数据帧如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>bytes::Bytes;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">enum</span> <span style="color:#b06;font-weight:bold">Frame</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Simple(<span style="color:#007020">String</span>),<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Error(<span style="color:#007020">String</span>),<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Integer(<span style="color:#339;font-weight:bold">u64</span>),<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Bulk(Bytes),<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Null,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>Array(<span style="color:#007020">Vec</span><span style="color:#333">&lt;</span>Frame<span style="color:#333">&gt;</span>),<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>一个HTTP协议的帧可能会长这样：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">enum</span> <span style="color:#b06;font-weight:bold">HttpFrame</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>RequestHead<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>method: <span style="color:#b06;font-weight:bold">Method</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>uri: <span style="color:#b06;font-weight:bold">Uri</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>version: <span style="color:#b06;font-weight:bold">Version</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>headers: <span style="color:#b06;font-weight:bold">HeaderMap</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span>ResponseHead<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>status: <span style="color:#b06;font-weight:bold">StatusCode</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>version: <span style="color:#b06;font-weight:bold">Version</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>headers: <span style="color:#b06;font-weight:bold">HeaderMap</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span>BodyChunk<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>chunk: <span style="color:#b06;font-weight:bold">Bytes</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>为了实现Mini-Redis，我们实现一个<code>Connection</code>结构体，它包装一个<code>TcpStream</code>并且读写<code>mini_redis::Frame</code>值。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpStream;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::{Frame,<span style="color:#bbb"> </span><span style="color:#007020">Result</span>};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Connection</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>stream: <span style="color:#b06;font-weight:bold">TcpStream</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// ... other fields here
</span><span style="color:#888"></span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">impl</span><span style="color:#bbb"> </span>Connection<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#d42;background-color:#fff0f0">/// Read a frame from the connection.
</span><span style="color:#d42;background-color:#fff0f0"></span><span style="color:#bbb">    </span><span style="color:#d42;background-color:#fff0f0">/// 
</span><span style="color:#d42;background-color:#fff0f0"></span><span style="color:#bbb">    </span><span style="color:#d42;background-color:#fff0f0">/// Returns `None` if EOF is reached
</span><span style="color:#d42;background-color:#fff0f0"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">read_frame</span>(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>self)<span style="color:#bbb">
</span><span style="color:#bbb">        </span>-&gt; <span style="color:#007020">Result</span><span style="color:#333">&lt;</span><span style="color:#007020">Option</span><span style="color:#333">&lt;</span>Frame<span style="color:#333">&gt;&gt;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// implementation here
</span><span style="color:#888"></span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#d42;background-color:#fff0f0">/// Write a frame to the connection.
</span><span style="color:#d42;background-color:#fff0f0"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">write_frame</span>(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>self,<span style="color:#bbb"> </span>frame: <span style="color:#038;font-weight:bold">&amp;</span><span style="color:#b06;font-weight:bold">Frame</span>)<span style="color:#bbb">
</span><span style="color:#bbb">        </span>-&gt; <span style="color:#007020">Result</span><span style="color:#333">&lt;</span>()<span style="color:#333">&gt;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// implementation here
</span><span style="color:#888"></span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>完整的代码在<a href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/connection.rs" target="_blank">这里</a>。</p>
<h2 id="缓冲读">缓冲读</h2>
<p><code>read_frame</code>方法等待接收到一个完整的帧，这是因为一次<code>read</code>读到的数据是不确定的（流式传输的特点），可能有多个帧，也可能只传输了部分帧。因此如果读到了不完整的一个帧，我们将数据存放在缓冲区等待新的数据，如果读到了多个帧，我们一次只返回一个帧，剩下的也放在缓冲区，用于下次<code>read_frame</code>调用。</p>
<p>为了实现这样的想法，<code>Connection</code>需要一个读缓冲区，数据将从socket读到缓冲区，当一个完整的帧解析成功，我们就把对应的数据移除。</p>
<p>我们使用<code>BytesMut</code>作为缓冲区的类型，这是<code>Bytes</code>类型的可变版本。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>bytes::BytesMut;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpStream;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Connection</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>stream: <span style="color:#b06;font-weight:bold">TcpStream</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>buffer: <span style="color:#b06;font-weight:bold">BytesMut</span>,<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">impl</span><span style="color:#bbb"> </span>Connection<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">new</span>(stream: <span style="color:#b06;font-weight:bold">TcpStream</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">Connection</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>Connection<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span>stream,<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Allocate the buffer with 4kb of capacity.
</span><span style="color:#888"></span><span style="color:#bbb">            </span>buffer: <span style="color:#b06;font-weight:bold">BytesMut</span>::with_capacity(<span style="color:#00d;font-weight:bold">4096</span>),<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>然后我们再来实现<code>read_frame</code>：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::io::AsyncReadExt;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>bytes::Buf;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::<span style="color:#007020">Result</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">read_frame</span>(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>self)<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-&gt; <span style="color:#007020">Result</span><span style="color:#333">&lt;</span><span style="color:#007020">Option</span><span style="color:#333">&lt;</span>Frame<span style="color:#333">&gt;&gt;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Attempt to parse a frame from the buffered data. If
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// enough data has been buffered, the frame is
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// returned.
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(frame)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>self.parse_frame()<span style="color:#333">?</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#007020">Ok</span>(<span style="color:#007020">Some</span>(frame));<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// There is not enough buffered data to read a frame.
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// Attempt to read more data from the socket.
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">//
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// On success, the number of bytes is returned. `0`
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// indicates &#34;end of stream&#34;.
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">0</span><span style="color:#bbb"> </span><span style="color:#333">==</span><span style="color:#bbb"> </span>self.stream.read_buf(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>self.buffer).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// The remote closed the connection. For this to be
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#888">// a clean shutdown, there should be no data in the
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#888">// read buffer. If there is, this means that the
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#888">// peer closed the socket while sending a frame.
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span>self.buffer.is_empty()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#080;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#007020">Ok</span>(<span style="color:#007020">None</span>);<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">else</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#080;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#007020">Err</span>(<span style="background-color:#fff0f0">&#34;connection reset by peer&#34;</span>.into());<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>我们分析一下，函数的主体在一个循环中，我们首先尝试从现有的缓冲区中解析出一个帧，如果解析成功，我们就可以将帧返回，如果解析不出，说明缓冲区内没有足够的数据。此时我们尝试把socket中接收到的数据读到buffer中，如果读到的数据量为0，要么帧已经完整解析完，socket里面没有数据了，这是正常的连接关闭，如果帧没有解析完，但是对方已经关闭连接，则属于不正常关闭，需要返回Err。</p>
<h3 id="buf-trait"><code>Buf</code> trait</h3>
<p>注意到我们这次从Tcp流中读取数据时用的方法是<code>read_buf</code>，此方法接收的参数必须实现<code>bytes</code>包中的<code>BufMut</code>。</p>
<p>如果我们用<code>Vec&lt;u8&gt;</code>来实现，则可以直接使用前面用到的<code>read()</code>方法，此时需要一个<code>cursor</code>来表示当前缓存的数据的尾部，<code>Connection</code>的定义需要修改为如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>tokio::net::TcpStream;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">Connection</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span>stream: <span style="color:#b06;font-weight:bold">TcpStream</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>buffer: <span style="color:#007020">Vec</span><span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">u8</span><span style="color:#333">&gt;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span>cursor: <span style="color:#339;font-weight:bold">usize</span>,<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">impl</span><span style="color:#bbb"> </span>Connection<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">new</span>(stream: <span style="color:#b06;font-weight:bold">TcpStream</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">Connection</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>Connection<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span>stream,<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Allocate the buffer with 4kb of capacity.
</span><span style="color:#888"></span><span style="color:#bbb">            </span>buffer: <span style="color:#b06;font-weight:bold">vec</span><span style="color:#333">!</span>[<span style="color:#00d;font-weight:bold">0</span>;<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">4096</span>],<span style="color:#bbb">
</span><span style="color:#bbb">            </span>cursor: <span style="color:#00d;font-weight:bold">0</span>,<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>此时<code>read_frame</code>函数也要修改：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::{Frame,<span style="color:#bbb"> </span><span style="color:#007020">Result</span>};<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">async</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">read_frame</span>(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>self)<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-&gt; <span style="color:#007020">Result</span><span style="color:#333">&lt;</span><span style="color:#007020">Option</span><span style="color:#333">&lt;</span>Frame<span style="color:#333">&gt;&gt;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">loop</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#007020">Some</span>(frame)<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>self.parse_frame()<span style="color:#333">?</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#007020">Ok</span>(<span style="color:#007020">Some</span>(frame));<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Ensure the buffer has capacity
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span>self.buffer.len()<span style="color:#bbb"> </span><span style="color:#333">==</span><span style="color:#bbb"> </span>self.cursor<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Grow the buffer
</span><span style="color:#888"></span><span style="color:#bbb">            </span>self.buffer.resize(self.cursor<span style="color:#bbb"> </span><span style="color:#333">*</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">2</span>,<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">0</span>);<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Read into the buffer, tracking the number
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#888">// of bytes read
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>n<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>self.stream.read(<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>self.buffer[self.cursor..]).<span style="color:#080;font-weight:bold">await</span><span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">0</span><span style="color:#bbb"> </span><span style="color:#333">==</span><span style="color:#bbb"> </span>n<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">if</span><span style="color:#bbb"> </span>self.cursor<span style="color:#bbb"> </span><span style="color:#333">==</span><span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">0</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#080;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#007020">Ok</span>(<span style="color:#007020">None</span>);<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">else</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#080;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#007020">Err</span>(<span style="background-color:#fff0f0">&#34;connection reset by peer&#34;</span>.into());<span style="color:#bbb">
</span><span style="color:#bbb">            </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">else</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Update our cursor
</span><span style="color:#888"></span><span style="color:#bbb">            </span>self.cursor<span style="color:#bbb"> </span><span style="color:#333">+=</span><span style="color:#bbb"> </span>n;<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p>可以看到我们必须要使用<code>cursor</code>来保证新读取的数据不会覆盖还未处理完成的数据，同时如果缓冲区的容量用完了，我们必须手动把缓冲区扩容，在<code>parse_frame</code>中，我们需要处理的部分是<code>self.buffer[..self.cursor]</code>。</p>
<p>因为这样的字节数组的处理非常常见，<code>bytes</code>包提供了高级的抽象：<code>Buf</code>和<code>BufMut</code>。<code>Buf</code>指的是可读的数据，<code>BufMut</code>指可写数据类型。当我们将实现了<code>BufMut</code>的实例传入<code>read_buf</code>时，<code>read_buf</code>会帮你处理内部的<code>cursor</code>，这使得外部代码更简洁。</p>
<p>此外，当我们使用<code>Vec&lt;u8&gt;</code>时，buffer必须要初始化，上面的代码就初始化成4KB的大小，每个位置都是0。当我们扩容的时候，新的内容也是初始化为零。初始化过程是非必须的，因为反正后面读的时候也是要覆盖掉原来的数据的。我们的<code>BytesMut</code> 的实现保证了数据不会初始化，省去了这一开销，同时它也在API层面禁止用户访问未初始化的数据。</p>
<h2 id="parsing">Parsing</h2>
<p>现在我们看如何实现<code>parse_frame</code>函数，解析帧需要两步：</p>
<ol>
<li>读完整的一个帧，定位到尾部。</li>
<li>解析这个帧。</li>
</ol>
<p><code>mini_redis</code>包提供了两个函数处理这个事：<code>Frame::check</code>和<code>Frame::parse</code>。</p>
<p>同时我们也会用到<code>Buf</code>，<code>Buf</code>类型的数据将被传入<code>check</code>，check会检查一个帧，同时移动内部的<code>cursor</code>，当其返回时，内部的<code>cursor</code>就会指向帧的尾部。<code>std::io::Cursor</code>就实现了<code>Buf</code>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::{Frame,<span style="color:#bbb"> </span><span style="color:#007020">Result</span>};<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>mini_redis::frame::Error::Incomplete;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>bytes::Buf;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::io::Cursor;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">parse_frame</span>(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>self)<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-&gt; <span style="color:#007020">Result</span><span style="color:#333">&lt;</span><span style="color:#007020">Option</span><span style="color:#333">&lt;</span>Frame<span style="color:#333">&gt;&gt;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Create the `T: Buf` type.
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buf<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Cursor::new(<span style="color:#333">&amp;</span>self.buffer[..]);<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#888">// Check whether a full frame is available
</span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">match</span><span style="color:#bbb"> </span>Frame::check(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buf)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#007020">Ok</span>(_)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Get the byte length of the frame
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>len<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>buf.position()<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">as</span><span style="color:#bbb"> </span><span style="color:#339;font-weight:bold">usize</span>;<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Reset the internal cursor for the
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#888">// call to `parse`.
</span><span style="color:#888"></span><span style="color:#bbb">            </span>buf.set_position(<span style="color:#00d;font-weight:bold">0</span>);<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Parse the frame
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>frame<span style="color:#bbb"> </span><span style="color:#333">=</span><span style="color:#bbb"> </span>Frame::parse(<span style="color:#333">&amp;</span><span style="color:#080;font-weight:bold">mut</span><span style="color:#bbb"> </span>buf)<span style="color:#333">?</span>;<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Discard the frame from the buffer
</span><span style="color:#888"></span><span style="color:#bbb">            </span>self.buffer.advance(len);<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#888">// Return the frame to the caller.
</span><span style="color:#888"></span><span style="color:#bbb">            </span><span style="color:#007020">Ok</span>(<span style="color:#007020">Some</span>(frame))<span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// Not enough data has been buffered
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#007020">Err</span>(Incomplete)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span><span style="color:#007020">Ok</span>(<span style="color:#007020">None</span>),<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#888">// An error was encountered
</span><span style="color:#888"></span><span style="color:#bbb">        </span><span style="color:#007020">Err</span>(e)<span style="color:#bbb"> </span><span style="color:#333">=&gt;</span><span style="color:#bbb"> </span><span style="color:#007020">Err</span>(e.into()),<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p><code>check</code>函数的实现在<a href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/frame.rs#L63-L100" target="_blank">这里</a>。我们不会完整讲解这个函数。</p>
<p>注意到，<code>Buf</code>的API是字节迭代器风格的，例如我们需要查看第一个字节来判断帧的类型，用到的方法是<code>Buf::get_u8</code>，它读取当前<code>cursor</code>位置的1个字节，并将cursor后移1位。还有很多好用的方法，请阅读<a href="https://docs.rs/bytes/0.6/bytes/buf/trait.Buf.html" target="_blank">API文档</a> 。</p>
<h2 id="缓冲写">缓冲写</h2>
<p>framing的另一个API是<code>write_frame(frame)</code>。</p>
	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			<a href="/categories/%e6%8a%80%e6%9c%af%e6%96%87%e6%a1%a3/"> 技术文档 </a>
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Series</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			<a href="/series/rust%e7%b3%bb%e5%88%97/"> rust系列 </a>
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Tags</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			<a href="/tags/rust/"> rust </a>
			
			
			
			
			
			<a href="/tags/tokio/"> tokio </a>
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
		
	</div></div>

  </main>
<footer>
	 © Copyright notice | <a href="https://github.com/dataCobra/hugo-vitae">Vitae</a> theme for <a href="https://gohugo.io">Hugo</a> 
	
	
	
</footer>


</body>
</html>
