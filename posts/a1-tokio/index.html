<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.80.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="一只特立独行的猫" />
  <meta property="og:url" content="https://zijiaw.github.io/posts/a1-tokio/" />
  <link rel="canonical" href="https://zijiaw.github.io/posts/a1-tokio/" /><link rel="alternate" type="application/atom+xml" href="https://zijiaw.github.io/index.xml" title="一只特立独行的猫">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/zijiaw.github.io\/"
      },
      "articleSection" : "posts",
      "name" : "Tokio Guide 中文翻译",
      "headline" : "Tokio Guide 中文翻译",
      "description" : "本文是阅读新版tokio文档，顺便翻译之作，啥时候读完啥时候写完咯。\nIntruduction 本教程将一步步带你构建一个简化的Redis客户端和服务器。我们首先介绍Rust中异步编程的基本概念，而后实现Redis命令的一个子集。\nMini-Redis 安装完成Rust以后，请安装Mini-Redis服务器程序，这可以用来测试我们的程序：\ncargo install mini-redis\r你可以键入如下命令开始程序：\nmini-redis-server\r而后你可以另起一个命令行，用自带的客户端程序尝试获取键foo：\nmini-redis-cli get foo\r你将看到输出为nil。\nHello Tokio 引入 我们首先编写非常基础的Tokio应用，它将连接到我们的Mini-Redis服务器，插入键值对\u0026lt;hello, world\u0026gt;，而后我们用cli包来获取它，以验证正确性。\n首先我们用carge创建新的Rust应用目录：\ncargo new my-redis\rcd my-redis\r而后编辑Cargo.toml，添加依赖：\ntokio = { version = \u0026quot;0.3\u0026quot;, features = [\u0026quot;full\u0026quot;] }\rmini-redis = \u0026quot;0.3\u0026quot;\r现在我们可以编辑main.rs，代码如下：\nuse mini_redis::{client, Result}; #[tokio::main] pub async fn main() -\u0026gt; Result\u0026lt;()\u0026gt; { \/\/ Open a connection to the mini-redis address.  let mut client = client::connect(\u0026#34;127.0.0.1:6379\u0026#34;).await?; \/\/ Set the key \u0026#34;hello\u0026#34; with value \u0026#34;world\u0026#34;  client.",
      "inLanguage" : "en-US",
      "author" : "一只特立独行的猫",
      "creator" : "一只特立独行的猫",
      "publisher": "一只特立独行的猫",
      "accountablePerson" : "一只特立独行的猫",
      "copyrightHolder" : "一只特立独行的猫",
      "copyrightYear" : "2021",
      "datePublished": "2021-01-18 00:00:00 \u002b0000 UTC",
      "dateModified" : "2021-01-18 00:00:00 \u002b0000 UTC",
      "url" : "https:\/\/zijiaw.github.io\/posts\/a1-tokio\/",
      "keywords" : [  ]
  }
</script>
<title>Tokio Guide 中文翻译</title>
  <meta property="og:title" content="Tokio Guide 中文翻译" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="本文是阅读新版tokio文档，顺便翻译之作，啥时候读完啥时候写完咯。
Intruduction 本教程将一步步带你构建一个简化的Redis客户端和服务器。我们首先介绍Rust中异步编程的基本概念，而后实现Redis命令的一个子集。
Mini-Redis 安装完成Rust以后，请安装Mini-Redis服务器程序，这可以用来测试我们的程序：
cargo install mini-redis你可以键入如下命令开始程序：
mini-redis-server而后你可以另起一个命令行，用自带的客户端程序尝试获取键foo：
mini-redis-cli get foo你将看到输出为nil。
Hello Tokio 引入 我们首先编写非常基础的Tokio应用，它将连接到我们的Mini-Redis服务器，插入键值对&amp;lt;hello, world&amp;gt;，而后我们用cli包来获取它，以验证正确性。
首先我们用carge创建新的Rust应用目录：
cargo new my-rediscd my-redis而后编辑Cargo.toml，添加依赖：
tokio = { version = &amp;quot;0.3&amp;quot;, features = [&amp;quot;full&amp;quot;] }mini-redis = &amp;quot;0.3&amp;quot;现在我们可以编辑main.rs，代码如下：
use mini_redis::{client, Result}; #[tokio::main] pub async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; { // Open a connection to the mini-redis address.  let mut client = client::connect(&amp;#34;127.0.0.1:6379&amp;#34;).await?; // Set the key &amp;#34;hello&amp;#34; with value &amp;#34;world&amp;#34;  client." />
  <meta name="description" content="本文是阅读新版tokio文档，顺便翻译之作，啥时候读完啥时候写完咯。
Intruduction 本教程将一步步带你构建一个简化的Redis客户端和服务器。我们首先介绍Rust中异步编程的基本概念，而后实现Redis命令的一个子集。
Mini-Redis 安装完成Rust以后，请安装Mini-Redis服务器程序，这可以用来测试我们的程序：
cargo install mini-redis你可以键入如下命令开始程序：
mini-redis-server而后你可以另起一个命令行，用自带的客户端程序尝试获取键foo：
mini-redis-cli get foo你将看到输出为nil。
Hello Tokio 引入 我们首先编写非常基础的Tokio应用，它将连接到我们的Mini-Redis服务器，插入键值对&amp;lt;hello, world&amp;gt;，而后我们用cli包来获取它，以验证正确性。
首先我们用carge创建新的Rust应用目录：
cargo new my-rediscd my-redis而后编辑Cargo.toml，添加依赖：
tokio = { version = &amp;quot;0.3&amp;quot;, features = [&amp;quot;full&amp;quot;] }mini-redis = &amp;quot;0.3&amp;quot;现在我们可以编辑main.rs，代码如下：
use mini_redis::{client, Result}; #[tokio::main] pub async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; { // Open a connection to the mini-redis address.  let mut client = client::connect(&amp;#34;127.0.0.1:6379&amp;#34;).await?; // Set the key &amp;#34;hello&amp;#34; with value &amp;#34;world&amp;#34;  client." />
  <meta property="og:locale" content="zh-cn" />

  
    <style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:underline;text-decoration-color:#000}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:100%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-date,.posts-title{font-size:1.2rem}.posts-line{margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px;margin-bottom:3px}.site-footer{margin-top:50px}.site-footer-item{margin-right:12px}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{text-align:center}.post-content{padding:0 12px}.post-content p{letter-spacing:.05em}}@media screen and (max-width:48em){.posts-category{display:none}}.post-content img{max-width:100%;display:block;margin-left:auto;margin-right:auto;margin-top:12px}.post-header{margin-bottom:50px}.post-title{font-size:2.5rem;font-weight:600}.post-category{display:inline;font-weight:900;padding:2px 5px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}</style>
  
  
    <style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style>
  

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="一只特立独行的猫">
  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel="stylesheet">
  
  

  
  
</head>


<body>
  <article class="post Chinese" id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="header-title">
    <a href="/"
      >一只特立独行的猫</a
    >
  </div>
  <div class="header-subtitle"></div>
</header>
<div class="row end-md center-xs header-items">
  
  <div class="header-item">
    <a href="https://github.com/ZiJiaW/" target="_blank">GitHub</a>
  </div>
  
  <div class="header-item">
    <a href="https://www.linkedin.com/in/zijia-wang-865a661a4/" target="_blank">LinkedIn</a>
  </div>
  
  <div class="header-item">
    <a href="mailto:zijiaw@outlook.com" target="_blank">Email</a>
  </div>
  
</div>
<div class="row end-xs">
   
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">Tokio Guide 中文翻译</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2021-01-18 00:00:00 UTC">
                18 Jan 2021
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https://zijiaw.github.io/">@一只特立独行的猫</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <p>本文是阅读新版tokio文档，顺便翻译之作，啥时候读完啥时候写完咯。</p>
<h2 id="intruduction">Intruduction</h2>
<p>本教程将一步步带你构建一个简化的Redis客户端和服务器。我们首先介绍Rust中异步编程的基本概念，而后实现Redis命令的一个子集。</p>
<h3 id="mini-redis">Mini-Redis</h3>
<p>安装完成Rust以后，请安装Mini-Redis服务器程序，这可以用来测试我们的程序：</p>
<pre><code>cargo install mini-redis
</code></pre><p>你可以键入如下命令开始程序：</p>
<pre><code>mini-redis-server
</code></pre><p>而后你可以另起一个命令行，用自带的客户端程序尝试获取键<code>foo</code>：</p>
<pre><code>mini-redis-cli get foo
</code></pre><p>你将看到输出为<code>nil</code>。</p>
<h2 id="hello-tokio">Hello Tokio</h2>
<h3 id="引入">引入</h3>
<p>我们首先编写非常基础的Tokio应用，它将连接到我们的Mini-Redis服务器，插入键值对<code>&lt;hello, world&gt;</code>，而后我们用<code>cli</code>包来获取它，以验证正确性。</p>
<p>首先我们用carge创建新的Rust应用目录：</p>
<pre><code>cargo new my-redis
cd my-redis
</code></pre><p>而后编辑<code>Cargo.toml</code>，添加依赖：</p>
<pre><code>tokio = { version = &quot;0.3&quot;, features = [&quot;full&quot;] }
mini-redis = &quot;0.3&quot;
</code></pre><p>现在我们可以编辑<code>main.rs</code>，代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> mini_redis::{client, Result};

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#75715e">// Open a connection to the mini-redis address.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> client <span style="color:#f92672">=</span> client::connect(<span style="color:#e6db74">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    <span style="color:#75715e">// Set the key &#34;hello&#34; with value &#34;world&#34;
</span><span style="color:#75715e"></span>    client.set(<span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span>.into()).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    <span style="color:#75715e">// Get key &#34;hello&#34;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> client.get(<span style="color:#e6db74">&#34;hello&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;got value from the server; result={:?}&#34;</span>, result);

    Ok(())
}
</code></pre></div><p>现在请在另一个终端运行server，然后运行main，你将得到：</p>
<pre><code>cargo run
got value from the server; result=Some(b&quot;world&quot;)
</code></pre><h3 id="分析">分析</h3>
<p>我们来看看我们刚刚的程序做了什么，实际上没有几行代码，但是确实发生了很多事情。首先，<code>client::connect</code>函数由mini-redis包提供，它异步地创建了一个TCP连接。一旦连接建立完成，一个<code>client</code>句柄将被返回。即使整个过程是异步的，但是我们看到的代码似乎是同步的，唯一的暗示在于我们用到的<code>await</code>操作符。</p>
<h4 id="什么是异步编程">什么是异步编程</h4>
<p>大多是程序的运行顺序和编写顺序是一致的，首先执行第一行，然后第二行，以此类推。在同步编程中，如果程序遇到一条无法立即返回的指令，它将阻塞在这里，直到指令完成。例如，创建一个TCP连接需要三次握手，这可能花费很长时间，在同步编程中，当前线程将会阻塞。</p>
<p>在异步编程中，无法立刻返回的指令将被暂停挂在后台，而当前线程可以继续执行其他操作。一旦该指令完成，任务将重新在暂停的地方开始被恢复执行。我们的例子中只有一个任务，所以在挂起的时候程序没干别的事情，但是通常异步程序会拥有很多异步任务需要调度。</p>
<p>尽管异步编程可以使程序运行更高效，但它也使得程序逻辑变得复杂。程序员需要考虑所有必要的状态来恢复暂停的任务。历史上，这是一件很冗杂无聊和易出错的事情。</p>
<h4 id="编译时绿色线程">编译时绿色线程</h4>
<p>Rust使用<code>async/await</code>特性来实现异步编程。所有包含异步操作的函数使用<code>async</code>来标记，在我们上面的例子中，<code>connect</code>函数的定义如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> mini_redis::Result;
<span style="color:#66d9ef">use</span> mini_redis::client::Client;
<span style="color:#66d9ef">use</span> tokio::net::ToSocketAddrs;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">connect</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">ToSocketAddrs</span><span style="color:#f92672">&gt;</span>(addr: <span style="color:#a6e22e">T</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Client<span style="color:#f92672">&gt;</span> {
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>这里的<code>async fn</code>的定义看起来和普通的同步函数一样，但是执行的时候是异步的。Rust在编译时就将异步函数转换成一个异步的任务。在异步函数内调用<code>await</code>时，调度器会把当前任务挂起，转而在此线程上执行其他任务，此异步任务将在别处处理（操作系统接受网络数据，或者读取文件等等）。</p>
<blockquote>
<p>其他一些语言也实现了<code>async/await</code>特性，但是Rust的实现方式是独特的。Rust的async操作是lazy的，这使得其运行时语义不同于其他语言。</p>
</blockquote>
<p>如果目前为止的内容你还难以理解，别担心，我们后续会有更详细的解释。</p>
<h4 id="使用asyncawait">使用async/await</h4>
<p>异步函数的调用和普通函数无异。然而，单单调用并不会执行这些函数的函数体。调用一个async函数仅仅是返回一个代表这一异步操作的值，这在概念上类似于一个无参数的闭包。我们必须显式调用<code>.await</code>操作符才能获得函数真正的返回值。看下面的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">say_world</span>() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;world&#34;</span>);
}

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// Calling `say_world()` does not execute the body of `say_world()`.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> op <span style="color:#f92672">=</span> say_world();

    <span style="color:#75715e">// This println! comes first
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);

    <span style="color:#75715e">// Calling `.await` on `op` starts executing `say_world`.
</span><span style="color:#75715e"></span>    op.<span style="color:#66d9ef">await</span>;
}
</code></pre></div><p>这段代码输出：</p>
<pre><code>hello
world
</code></pre><p>实际上，异步函数的返回值是一个实现了<code>Future</code>的匿名类型值。</p>
<h4 id="异步的main函数">异步的main函数</h4>
<p>上面的程序中的main函数和通常的Rust应用不同，它是异步的，并且使用<code>#[tokio::main]</code>作了注解。当我们在函数中用到异步操作符的时候，该函数需要定义为async的。而async函数必须要用一个运行时去执行。该运行时需要包含异步任务调度器，并且提供内部的定时器，事件驱动型的IO框架等。这一运行时也需要main函数来启动。</p>
<p><code>#[tokio::main]</code>是一个宏，它将<code>async fn main()</code>转化为一个同步的<code>main()</code>函数，并在其中初始化运行时并执行异步的main函数。例如，下面一段程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
}
</code></pre></div><p>将被转化成：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> rt <span style="color:#f92672">=</span> tokio::runtime::Runtime::new().unwrap();
    rt.block_on(<span style="color:#66d9ef">async</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
    })
}
</code></pre></div><p>Tokio运行时的细节将在后面谈到。</p>
<h4 id="cargo-features">Cargo features</h4>
<p>当用到tokio的时候，我们设置了features为full：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml"><span style="color:#a6e22e">tokio</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.3&#34;</span>, <span style="color:#a6e22e">features</span> = [<span style="color:#e6db74">&#34;full&#34;</span>] }
</code></pre></div><p>Tokio本身有很多功能（TCP, UDP, Unix sockets, timers, sync utilities, multple scheduler types, etc）。并不是所有应用都会用到全部的功能。当我们尝试优化应用的编译时长或最终生成的软件大小时，可以砍掉一些没有用到的feature。</p>
<p>但是目前为止，我们直接使用full就好了。</p>
<h2 id="spawning">Spawning</h2>
<p>我们现在真正开始实现我们的Redis服务。首先我们把上一节用到的代码移到example包里，我们可以用它来测试我们自己的Redis服务器。</p>
<pre><code>mkdir -p examples
mv src/main.rs examples/hello-redis.rs
</code></pre><p>然后我们新建一个空的<code>src/main.rs</code>文件。</p>
<h3 id="接受新的socket连接">接受新的socket连接</h3>
<p>Redis服务器第一件要干的事情就是监听固定端口上的TCP连接请求，这可以用<code>tokio::net::TcpListener</code>完成。</p>
<blockquote>
<p>许多Tokio的内部类型都和Rust标准库里的同步等价物命名相同。Tokio合理地将标准库里地一些API以异步的方式重新暴露给用户使用。</p>
</blockquote>
<p>一个TcpListener绑定带6379号端口，而后我们在一个循环中接收连接，每一个连接都被处理一次，然后关闭。目前，我们只读取接受到的命令然后输出到stdout，然后向客户端响应一个error。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::net::{TcpListener, TcpStream};
<span style="color:#66d9ef">use</span> mini_redis::{Connection, Frame};

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// Bind the listener to the address
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> listener <span style="color:#f92672">=</span> TcpListener::bind(<span style="color:#e6db74">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#66d9ef">await</span>.unwrap();
    <span style="color:#66d9ef">loop</span> {
        <span style="color:#75715e">// The second item contains the IP and port of the new connection.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> (socket, _) <span style="color:#f92672">=</span> listener.accept().<span style="color:#66d9ef">await</span>.unwrap();
        process(socket).<span style="color:#66d9ef">await</span>;
    }
}

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(socket: <span style="color:#a6e22e">TcpStream</span>) {
    <span style="color:#75715e">// The `Connection` lets us read/write redis **frames** instead of
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// byte streams. The `Connection` type is defined by mini-redis.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> connection <span style="color:#f92672">=</span> Connection::new(socket);

    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(frame) <span style="color:#f92672">=</span> connection.read_frame().<span style="color:#66d9ef">await</span>.unwrap() {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;GOT: {:?}&#34;</span>, frame);

        <span style="color:#75715e">// Respond with an error
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> Frame::Error(<span style="color:#e6db74">&#34;unimplemented&#34;</span>.to_string());
        connection.write_frame(<span style="color:#f92672">&amp;</span>response).<span style="color:#66d9ef">await</span>.unwrap();
    }
}
</code></pre></div><p>现在我们运行一下：</p>
<pre><code>cargo run
</code></pre><p>在另一个终端我们运行之前的example的hello-redis：</p>
<pre><code>cargo run --example hello-redis
</code></pre><p>输出应该是：</p>
<pre><code>Error: &quot;unimplemented&quot;
</code></pre><p>在服务器的终端上应该显示如下：</p>
<pre><code>GOT: Array([Bulk(b&quot;set&quot;), Bulk(b&quot;hello&quot;), Bulk(b&quot;world&quot;)])
</code></pre><h3 id="并发执行">并发执行</h3>
<p>除了只返回error以外，上面的程序有一个小问题，它只能一次处理一个连接。当一个连接被接受以后，服务器程序将执行process程序，处理完成后才开始接受新的请求。</p>
<p>我们希望我们的Redis服务器能够同时处理大量请求，这需要一些并发。</p>
<blockquote>
<p>并发和并行不是一个东西。如果你在两个任务之间来回切换，你是在并发执行两个任务，但并非并行。并行指的是你必须有两个不同的个体各自同时执行一个任务。在计算机中，达到并行必须使用多个线程在多核处理器上运行。</p>
<p>使用Tokio的好处在于异步编程能够让许多任务并发执行，而不需要手动开启多个原生线程。事实上，Tokio调度器可以让许多任务在单线程上并发执行。</p>
</blockquote>
<p>为了并发地处理连接请求，我们需要在每一次连接到来的时候发布（spawn）一个新的任务，此任务包含连接的处理逻辑，我们把main函数改成这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::net::TcpListener;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> listener <span style="color:#f92672">=</span> TcpListener::bind(<span style="color:#e6db74">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#66d9ef">await</span>.unwrap();
    <span style="color:#66d9ef">loop</span> {
        <span style="color:#66d9ef">let</span> (socket, _) <span style="color:#f92672">=</span> listener.accept().<span style="color:#66d9ef">await</span>.unwrap();
        <span style="color:#75715e">// A new task is spawned for each inbound socket. The socket is
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// moved to the new task and processed there.
</span><span style="color:#75715e"></span>        tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
            process(socket).<span style="color:#66d9ef">await</span>;
        });
    }
}
</code></pre></div><h4 id="任务">任务</h4>
<p>一个Tokio任务就是一个异步的绿色线程（或者说协程也不为过）。它们通过一个async块来创建，然后传入<code>tokio::spawn</code>函数来发布，该函数返回一个<code>JoinHandle</code>，调用者可以通过这一句柄和该任务交互。该async块有时会有返回值，可以通过在<code>JoinHandle</code>上调用<code>.await</code>来获得它。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> handle <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> {
        <span style="color:#75715e">// Do some async work
</span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;return value&#34;</span>
    });
    <span style="color:#75715e">// Do some other work
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> out <span style="color:#f92672">=</span> handle.<span style="color:#66d9ef">await</span>.unwrap();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;GOT {}&#34;</span>, out);
}
</code></pre></div><p>在该句柄上await将得到一个<code>Result</code>，如果任务执行过程中产生错误，会返回<code>Err</code>，这通常发生在任务发生panic，或者运行时异常宕机导致任务被取消的情况下。</p>
<p>Tokio任务是Tokio调度器管理的执行单元。当我们将任务发布后，该任务被提交给调度器，由调度器负责其执行。每一个任务可能就在当前线程执行，也可能被调度到不同的线程，也有可能在不同线程间切换。</p>
<p>Tokio中的任务是非常轻量级的，实际上创建它们仅消耗一次内存分配以及64字节的内存。你可以随意发布任务，当然别弄个几百万个就好。</p>
<h4 id="static限制">&lsquo;static限制</h4>
<p>当你发布一个任务时，它的类型必须是静态`static的，这意味着任务不能包含任何任务外部数据的引用。</p>
<blockquote>
<p>&lsquo;static并不总是意味着永生，一个值是&rsquo;static的并不意味着内存泄漏：你可以在<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#2-if-t-static-then-t-must-be-valid-for-the-entire-program">Common Rust Lifetime Misconceptions</a>上阅读更多。</p>
</blockquote>
<p>例如，下述代码无法编译通过：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::task;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
    task::spawn(<span style="color:#66d9ef">async</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Here&#39;s a vec: {:?}&#34;</span>, v);
    });
}
</code></pre></div><p>如果你尝试编译，将会出现如下的报错：</p>
<pre><code>error[E0373]: async block may outlive the current function, but
              it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:7:23
  |
7 |       task::spawn(async {
  |  _______________________^
8 | |         println!(&quot;Here's a vec: {:?}&quot;, v);
  | |                                        - `v` is borrowed here
9 | |     });
  | |_____^ may outlive borrowed value `v`
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:7:17
  |
7 |       task::spawn(async {
  |  _________________^
8 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
9 | |     });
  | |_____^
help: to force the async block to take ownership of `v` (and any other
      referenced variables), use the `move` keyword
  |
7 |     task::spawn(async move {
8 |         println!(&quot;Here's a vec: {:?}&quot;, v);
9 |     });
  |
</code></pre><p>这是因为，默认情况下，变量不会被移动到async块内，这里的<code>v</code>的所有权仍然归main函数，而<code>println!</code>借用了<code>v</code>。编译器解释了这一错误，并建议使用<code>move</code>关键字把<code>v</code>移动进去。修改后，任务就拥有了所有内部数据的所有权，成为&rsquo;static的了。如果你一定要让多个任务共享一个变量，则它必须用一些同步原语来包装，如线程安全的多重所有权指针<code>Arc</code>。</p>
<p>注意到错误信息提示：参数类型需要比&rsquo;static活得长。这听起来有点令人困惑，因为&rsquo;static变量的生命期等同整个程序，如果它比&rsquo;static活得长，岂不是内存泄漏了吗？解释如下：是类型需要活得长，而不是变量本身，变量在类型无效前就可以被销毁。</p>
<p>当我们说一个值是&rsquo;static的时候，它仅仅意味着：任意传递这个变量都不会出错。这很重要，因为编译器无法推断一个新发布的任务会存活多长时间，所以唯一的方法就是假定它可能会永生。</p>
<h4 id="send限制">Send限制</h4>
<p>被发布的任务必须实现了<code>Send</code>，这允许Tokio运行时将任务在不同线程间切换。当所有生命期跨过<code>.await</code>语句的变量是<code>Send</code>的时候，该任务是<code>Send</code>的。这有点微妙。当<code>.await</code>被调用时，任务挂起，然后调度器调度其他任务。下次这个任务被唤醒时，将在挂起的时候重新恢复执行，也就是说在<code>.await</code>之后用到的所有变量都会被保存。而恢复执行的线程可能不同于原来的线程，因此这些变量需要是<code>Send</code>的。</p>
<p>例如，下面这段代码是正确的，因为变量<code>rc</code>提前释放了，它没有跨越<code>await</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::task::yield_now;
<span style="color:#66d9ef">use</span> std::rc::Rc;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    tokio::spawn(<span style="color:#66d9ef">async</span> {
        <span style="color:#75715e">// The scope forces `rc` to drop before `.await`.
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">let</span> rc <span style="color:#f92672">=</span> Rc::new(<span style="color:#e6db74">&#34;hello&#34;</span>);
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, rc);
        }
        <span style="color:#75715e">// `rc` is no longer used. It is **not** persisted when
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the task yields to the scheduler
</span><span style="color:#75715e"></span>        yield_now().<span style="color:#66d9ef">await</span>;
    });
}
</code></pre></div><p>而下面这段代码无法编译通过：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::task::yield_now;
<span style="color:#66d9ef">use</span> std::rc::Rc;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    tokio::spawn(<span style="color:#66d9ef">async</span> {
        <span style="color:#66d9ef">let</span> rc <span style="color:#f92672">=</span> Rc::new(<span style="color:#e6db74">&#34;hello&#34;</span>);
        <span style="color:#75715e">// `rc` is used after `.await`. It must be persisted to
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the task&#39;s state.
</span><span style="color:#75715e"></span>        yield_now().<span style="color:#66d9ef">await</span>;
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, rc);
    });
}
</code></pre></div><p>编译错误如下：</p>
<pre><code>error: future cannot be sent between threads safely
   --&gt; src/main.rs:6:5
    |
6   |     tokio::spawn(async {
    |     ^^^^^^^^^^^^ future created by async block is not `Send`
    | 
   ::: [..]spawn.rs:127:21
    |
127 |         T: Future + Send + 'static,
    |                     ---- required by this bound in
    |                          `tokio::task::spawn::spawn`
    |
    = help: within `impl std::future::Future`, the trait
    |       `std::marker::Send` is not  implemented for
    |       `std::rc::Rc&lt;&amp;str&gt;`
note: future is not `Send` as this value is used across an await
   --&gt; src/main.rs:10:9
    |
7   |         let rc = Rc::new(&quot;hello&quot;);
    |             -- has type `std::rc::Rc&lt;&amp;str&gt;` which is not `Send`
...
10  |         yield_now().await;
    |         ^^^^^^^^^^^^^^^^^ await occurs here, with `rc` maybe
    |                           used later
11  |         println!(&quot;{}&quot;, rc);
12  |     });
    |     - `rc` is later dropped here
</code></pre><p>我们将在下一节深入讨论这个错误的一个特殊情况。</p>
<h4 id="保存数据">保存数据</h4>
<p>我们现在实现新的<code>process</code>函数，来处理新到达的请求。我们使用<code>HashMap</code>来保存数据。<code>SET</code>命令把数据存到哈希表中，而<code>GET</code>命令读取它们。同时我们循环读取一次连接中的多个命令。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::net::TcpStream;
<span style="color:#66d9ef">use</span> mini_redis::{Connection, Frame};

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(socket: <span style="color:#a6e22e">TcpStream</span>) {
    <span style="color:#66d9ef">use</span> mini_redis::Command::{self, Get, Set};
    <span style="color:#66d9ef">use</span> std::collections::HashMap;
    <span style="color:#75715e">// A hashmap is used to store data
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> db <span style="color:#f92672">=</span> HashMap::new();
    <span style="color:#75715e">// Connection, provided by `mini-redis`, handles parsing frames from
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the socket
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> connection <span style="color:#f92672">=</span> Connection::new(socket);
    <span style="color:#75715e">// Use `read_frame` to receive a command from the connection.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(frame) <span style="color:#f92672">=</span> connection.read_frame().<span style="color:#66d9ef">await</span>.unwrap() {
        <span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> Command::from_frame(frame).unwrap() {
            Set(cmd) <span style="color:#f92672">=&gt;</span> {
                <span style="color:#75715e">// The value is stored as `Vec&lt;u8&gt;`
</span><span style="color:#75715e"></span>                db.insert(cmd.key().to_string(), cmd.value().to_vec());
                Frame::Simple(<span style="color:#e6db74">&#34;OK&#34;</span>.to_string())
            }
            Get(cmd) <span style="color:#f92672">=&gt;</span> {
                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(value) <span style="color:#f92672">=</span> db.get(cmd.key()) {
                    <span style="color:#75715e">// `Frame::Bulk` expects data to be of type `Bytes`. This
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// type will be covered later in the tutorial. For now,
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// `&amp;Vec&lt;u8&gt;` is converted to `Bytes` using `into()`.
</span><span style="color:#75715e"></span>                    Frame::Bulk(value.clone().into())
                } <span style="color:#66d9ef">else</span> {
                    Frame::Null
                }
            }
            cmd <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;unimplemented {:?}&#34;</span>, cmd),
        };
        <span style="color:#75715e">// Write the response to the client
</span><span style="color:#75715e"></span>        connection.write_frame(<span style="color:#f92672">&amp;</span>response).<span style="color:#66d9ef">await</span>.unwrap();
    }
}
</code></pre></div><p>现在我们运行这个server：</p>
<pre><code>cargo run
</code></pre><p>在另一个终端运行<code>hello-redis</code>程序：</p>
<pre><code>cargo run --example hello-redis
</code></pre><p>我们可以看到输出为：</p>
<pre><code>got value from the server; success=Some(b&quot;world&quot;)
</code></pre><p>我们现在可以插入和读取数据了，但是这里有个问题：数据并没有在连接之间共享，如果另一个客户端想要读取相同的键值，它什么都读不到。在下一节我们来看看如何把数据跨连接保存并共享。</p>
<h2 id="共享状态">共享状态</h2>
<h3 id="策略">策略</h3>
<p>有很多策略都能够在Tokio中共享状态：</p>
<ol>
<li>用互斥锁来保护状态变量。</li>
<li>发布一个专门用于管理状态的任务，使用消息传递模式来操作状态。</li>
</ol>
<p>一般来说第一种方法用来管理简单的数据，第二种用于需要异步操作的工作，如IO操作。在本节，我们需要共享的状态是一个哈希表，对应的操作是插入和查询（insert和get），这些操作都是同步的，因此我们使用互斥锁即可。第二种方法将在下一节讲述。</p>
<h3 id="添加bytes包">添加bytes包</h3>
<p>我们的Mini-Redis使用<code>Bytes</code>数据结构，而不是<code>Vec&lt;u8&gt;</code>来表示字节流，前者来自<code>bytes</code>包。<code>Bytes</code>的设计目标是为网络编程提供健壮的字节数组。它与<code>Vec&lt;u8&gt;</code>的最大区别是浅拷贝。也就是说，当我们在<code>Bytes</code>实例上调用<code>clone()</code>方法时，并不会拷贝内部的数据，实际上它仅仅增加引用计数。在实现上，你可以认为近似于<code>Arc&lt;Vec&lt;u8&gt;&gt;</code>，只不过提供了更丰富的封装。</p>
<p>我们在Cargo.toml里添加：</p>
<pre><code>bytes = &quot;0.6&quot;
</code></pre><h3 id="初始化hashmap">初始化HashMap</h3>
<p>我们的哈希表会在许多任务间共享，因此用<code>Arc&lt;Mutex&lt;_&gt;&gt;</code>来封装即可。</p>
<p>首先我们为这一类型起个别名：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> bytes::Bytes;
<span style="color:#66d9ef">use</span> std::collections::HashMap;
<span style="color:#66d9ef">use</span> std::sync::{Arc, Mutex};
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Db</span> <span style="color:#f92672">=</span> Arc<span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>String, Bytes<span style="color:#f92672">&gt;&gt;&gt;</span>;
</code></pre></div><p>而后我们修改main函数进行初始化，将智能指针<code>Arc</code>传递给<code>process</code>函数，<code>Arc</code>是线程安全的引用计数指针。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::net::TcpListener;
<span style="color:#66d9ef">use</span> std::collections::HashMap;
<span style="color:#66d9ef">use</span> std::sync::{Arc, Mutex};

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> listener <span style="color:#f92672">=</span> TcpListener::bind(<span style="color:#e6db74">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#66d9ef">await</span>.unwrap();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Listening&#34;</span>);
    <span style="color:#66d9ef">let</span> db <span style="color:#f92672">=</span> Arc::new(Mutex::new(HashMap::new()));
    <span style="color:#66d9ef">loop</span> {
        <span style="color:#66d9ef">let</span> (socket, _) <span style="color:#f92672">=</span> listener.accept().<span style="color:#66d9ef">await</span>.unwrap();
        <span style="color:#75715e">// Clone the handle to the hash map.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> db <span style="color:#f92672">=</span> db.clone();
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Accepted&#34;</span>);
        tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
            process(socket, db).<span style="color:#66d9ef">await</span>;
        });
    }
}
</code></pre></div><h4 id="stdsyncmutex">std::sync::Mutex</h4>
<p>注意我们使用的是<code>std::sync::Mutex</code>而不是<code>tokio::sync::Mutex</code>。在同步的代码中使用<code>tokio::sync::Mutex</code>是错误的。异步的互斥锁是指其锁的范围跨越了<code>.await</code>操作符。</p>
<p>一个同步的互斥锁会使当前线程阻塞，等待获取锁，因此会使得当前线程无法再同时处理别的任务。使用<code>tokio::sync::Mutex</code>也并不会改变这种情况，因为异步的互斥锁在内部也是使用了原始的同步互斥锁。</p>
<p>通常的经验是，在异步代码块中使用同步互斥锁没啥问题，只要临界区很小并且锁不跨越<code>.await</code>。此外，你可以考虑使用<code>parking_lot::Mutex</code>，它比标准库的互斥锁更快一些。</p>
<h3 id="更新process函数">更新process函数</h3>
<p>process函数不再需要初始化哈希表了，它接收其实例的一个智能指针作为参数。在插入数据时，我们需要先加锁。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::net::TcpStream;
<span style="color:#66d9ef">use</span> mini_redis::{Connection, Frame};

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(socket: <span style="color:#a6e22e">TcpStream</span>, db: <span style="color:#a6e22e">Db</span>) {
    <span style="color:#66d9ef">use</span> mini_redis::Command::{self, Get, Set};
    <span style="color:#75715e">// Connection, provided by `mini-redis`, handles parsing frames from
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the socket
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> connection <span style="color:#f92672">=</span> Connection::new(socket);
    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(frame) <span style="color:#f92672">=</span> connection.read_frame().<span style="color:#66d9ef">await</span>.unwrap() {
        <span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> Command::from_frame(frame).unwrap() {
            Set(cmd) <span style="color:#f92672">=&gt;</span> {
                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> db <span style="color:#f92672">=</span> db.lock().unwrap();
                db.insert(cmd.key().to_string(), cmd.value().clone());
                Frame::Simple(<span style="color:#e6db74">&#34;OK&#34;</span>.to_string())
            }           
            Get(cmd) <span style="color:#f92672">=&gt;</span> {
                <span style="color:#66d9ef">let</span> db <span style="color:#f92672">=</span> db.lock().unwrap();
                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(value) <span style="color:#f92672">=</span> db.get(cmd.key()) {
                    Frame::Bulk(value.clone())
                } <span style="color:#66d9ef">else</span> {
                    Frame::Null
                }
            }
            cmd <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;unimplemented {:?}&#34;</span>, cmd),
        };
        <span style="color:#75715e">// Write the response to the client
</span><span style="color:#75715e"></span>        connection.write_frame(<span style="color:#f92672">&amp;</span>response).<span style="color:#66d9ef">await</span>.unwrap();
    }
}
</code></pre></div><h3 id="任务线程以及竞争">任务，线程以及竞争</h3>
<p>使用阻塞的互斥锁来保护短的临界区是很好的策略，尤其是竞争较小的情况。当锁被争用的时候，线程必须阻塞并且等待锁释放，这同时也导致当前线程被分配的其他任务也被阻塞。</p>
<p>默认情况下，Tokio运行时使用多线程的调度器。任务将在多个线程组成的线程池中调度执行。如果大量任务被发布并执行在不同线程中，且都需要获得哈希表的锁，那么就产生了竞争。换句话说，如果配置了<code>current_thread</code>，锁就不会被竞争。</p>
<blockquote>
<p><code>current_thread</code>运行时是一个轻量级，单线程的运行时。当我们发布的任务不是很多，且连接数也不多的情况下，单线程是很好的思路。</p>
</blockquote>
<p>如果锁的争用很剧烈，影响程序的性能，可以考虑下面的一些选项：</p>
<ul>
<li>使用专门的Task来管理状态，用消息传递模式。</li>
<li>把锁分片。</li>
<li>重构代码，不用互斥锁。</li>
</ul>
<p>在我们的例子中，因为哈希表中每个key都是独立的，锁分片是很好的策略，我们不使用单独的<code>Mutex&lt;HashMap&lt;_, _&gt;&gt;</code>，而是使用<code>N</code>个哈希表实例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShardedDb</span> <span style="color:#f92672">=</span> Arc<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>String, Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;&gt;&gt;&gt;&gt;</span>;
</code></pre></div><p>而后，寻找相应<code>key</code>所在的位置分两步：首先，利用哈希值确定key所在的哈希表，然后再查该哈希表。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> shard <span style="color:#f92672">=</span> db[hash(key) <span style="color:#f92672">%</span> db.len()].lock().unwrap();
shard.insert(key, value);
</code></pre></div><p><a href="https://docs.rs/dashmap">dashmap</a>包基于这一思想实现了分片的哈希表，提供更好的并发性能。</p>
<h3 id="跨await的锁">跨.await的锁</h3>
<p>你可能会写出如下的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::sync::Mutex;
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">increment_and_do_stuff</span>(mutex: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Mutex</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lock <span style="color:#f92672">=</span> mutex.lock().unwrap();
    <span style="color:#f92672">*</span>lock <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
    do_something_async().<span style="color:#66d9ef">await</span>;
} <span style="color:#75715e">// lock goes out of scope here
</span></code></pre></div><p>当你在Tokio任务中调用这一函数时，编译会报错：</p>
<pre><code>error: future cannot be sent between threads safely
   --&gt; src/lib.rs:13:5
    |
13  |     tokio::spawn(async move {
    |     ^^^^^^^^^^^^ future created by async block is not `Send`
    |
   ::: /playground/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-0.2.21/src/task/spawn.rs:127:21
    |
127 |         T: Future + Send + 'static,
    |                     ---- required by this bound in `tokio::task::spawn::spawn`
    |
    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard&lt;'_, i32&gt;`
note: future is not `Send` as this value is used across an await
   --&gt; src/lib.rs:7:5
    |
4   |     let mut lock = mutex.lock().unwrap();
    |         -------- has type `std::sync::MutexGuard&lt;'_, i32&gt;` which is not `Send`
...
7   |     do_something_async().await;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ await occurs here, with `mut lock` maybe used later
8   | }
    | - `mut lock` is later dropped here
</code></pre><p>错误原因是，<code>std::sync:MutexGuard</code>不是<code>Send</code>的。这意味着你不能让一个互斥锁跨线程传递。前面说过，Tokio调度器可能会让一个任务在多个线程上执行。为了解决这个问题，你必须要在<code>.await</code>之前释放锁：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// This works!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">increment_and_do_stuff</span>(mutex: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Mutex</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) {
    {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lock <span style="color:#f92672">=</span> mutex.lock().unwrap();
        <span style="color:#f92672">*</span>lock <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
    } <span style="color:#75715e">// lock goes out of scope here
</span><span style="color:#75715e"></span>    do_something_async().<span style="color:#66d9ef">await</span>;
}
</code></pre></div><p>注意，虽然看起来很对，但是下面这段代码无法通过编译：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::sync::Mutex;

<span style="color:#75715e">// This fails too.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">increment_and_do_stuff</span>(mutex: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Mutex</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lock <span style="color:#f92672">=</span> mutex.lock().unwrap();
    <span style="color:#f92672">*</span>lock <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
    drop(lock);
    do_something_async().<span style="color:#66d9ef">await</span>;
}
</code></pre></div><p>这是因为编译器目前仅根据作用域来判断一个<code>future</code>是否是<code>Send</code>的。将来可能会支持显式的<code>drop</code>，不过现在还是老老实实用大括号吧。</p>
<p>不要想着能不能在不要求<code>Send</code>的情况下发布任务来躲避这一问题（单线程调度器）。因为如果Tokio在await时挂起了你的任务，但锁还未释放，另一个任务可能会在同一线程执行，并请求同一个锁。此时就产生了死锁，因为当前线程阻塞，但是锁永远无法释放。</p>
<h4 id="其他办法">其他办法</h4>
<p>在await前通过作用域释放锁是一个办法，实际上还有更鲁棒的写法。例如，你可以把互斥锁包装在一个结构体中，然后通过一个方法来执行锁的逻辑。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::sync::Mutex;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">CanIncrement</span> {
    mutex: <span style="color:#a6e22e">Mutex</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>,
}
<span style="color:#66d9ef">impl</span> CanIncrement {
    <span style="color:#75715e">// This function is not marked async.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">increment</span>(<span style="color:#f92672">&amp;</span>self) {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lock <span style="color:#f92672">=</span> self.mutex.lock().unwrap();
        <span style="color:#f92672">*</span>lock <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
    }
}
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">increment_and_do_stuff</span>(can_incr: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">CanIncrement</span>) {
    can_incr.increment();
    do_something_async().<span style="color:#66d9ef">await</span>;
}
</code></pre></div><p>这一编程模式保证了上面的<code>Send</code>错误永远不会出现，因为锁根本就没有出现在异步块中。</p>
<p>另一个办法就是使用消息传递策略，我们将在下一节提到。</p>
<h4 id="tokio的异步锁">Tokio的异步锁</h4>
<p>我们前面提到的<code>tokio::sync::Mutex</code>终于派上用场了。它最主要的特性就是能够跨越<code>.await</code>，而不产生问题。当然这也意味着异步锁的性能损失更大，如果非必要，请用上面的两种策略，而不是用异步锁：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::sync::Mutex; <span style="color:#75715e">// note! This uses the Tokio mutex
</span><span style="color:#75715e">// This compiles!
</span><span style="color:#75715e">// (but restructuring the code would be better in this case)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">increment_and_do_stuff</span>(mutex: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Mutex</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lock <span style="color:#f92672">=</span> mutex.lock().<span style="color:#66d9ef">await</span>;
    <span style="color:#f92672">*</span>lock <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
    do_something_async().<span style="color:#66d9ef">await</span>;
} <span style="color:#75715e">// lock goes out of scope here
</span></code></pre></div><h2 id="channels">Channels</h2>
<p>现在我们已经学到了一些Tokio的异步知识了，本节我们来写写客户端。首先我们尝试发布Tokio任务来发送命令：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> mini_redis::client;
<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// Establish a connection to the server
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> client <span style="color:#f92672">=</span> client::connect(<span style="color:#e6db74">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#66d9ef">await</span>.unwrap();
    <span style="color:#75715e">// Spawn two tasks, one gets a key, the other sets a key
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> t1 <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> {
        <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(<span style="color:#e6db74">&#34;hello&#34;</span>).<span style="color:#66d9ef">await</span>;
    });
    <span style="color:#66d9ef">let</span> t2 <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> {
        client.set(<span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#e6db74">&#34;bar&#34;</span>.into()).<span style="color:#66d9ef">await</span>;
    });
    t1.<span style="color:#66d9ef">await</span>.unwrap();
    t2.<span style="color:#66d9ef">await</span>.unwrap();
}
</code></pre></div><p>上面这段代码并不能通过编译，因为两个任务都需要用到client变量，但是<code>Client</code>并没有实现<code>Copy</code>，因此这一共享是错误的。当然我们可以为每条命令都新建一个连接，但显然这很慢。</p>
<h3 id="消息传递">消息传递</h3>
<p>答案是使用消息传递模型，即我们使用专门的任务来管理<code>client</code>连接。任何想要发送新的命令的任务都把指令作为一条消息传递给该client任务，client任务负责把命令发送给服务端，然后再把消息传回原任务。</p>
<p>使用这一策略，我们只需要维护一个与服务端的连接即可。client任务能够很好地处理收到的命令，同时channel本身也起到缓冲的作用。此模型很好地提高吞吐量，同时也可以扩展成连接池模型。</p>
<h3 id="tokio的channel原语">Tokio的channel原语</h3>
<p>Tokio提供了许多类型的channel，每一个都提供不同的功能和设计目标：</p>
<ul>
<li><a href="https://docs.rs/tokio/0.3/tokio/sync/mpsc/index.html">mpsc</a>：多生产者，单消费者。可以一次传递多个值。</li>
<li><a href="https://docs.rs/tokio/0.3/tokio/sync/oneshot/index.html">oneshot</a>：单生产者，单消费者。一次只能传递一个值。</li>
<li><a href="https://docs.rs/tokio/0.3/tokio/sync/broadcast/index.html">broadcast</a>：多生产者，多消费者。一次传递多值，值能够被每个接收器看见。</li>
<li><a href="https://docs.rs/tokio/0.3/tokio/sync/watch/index.html">watch</a>：单生产者，多消费者。一次传递多值，不过不记录消息历史。接收器只能看见最近的值。</li>
</ul>
<p>如果你需要多生产者，多消费者的channel，并且只有一个接收器能看见全部值，你可以使用<a href="https://docs.rs/async-channel/">async-channel</a>包。在同步编程中也有一些channel，如std::sync::mpsc和<a href="https://docs.rs/crossbeam/latest/crossbeam/channel/index.html">crossbeam::channel</a>，这些channel在等待数据的时候会阻塞当前线程，而在Tokio异步编程中，当前线程不会阻塞。</p>
<p>在本节，我们会使用<code>mpsc</code>和<code>oneshot</code>，另外几种channel将在后续讲解。</p>
<h3 id="定义消息类型">定义消息类型</h3>
<p>在大多数情况下，当我们使用消息传递时，接收消息的任务常常需要响应多个累积的消息。在我们的例子中，该任务需要处理<code>GET</code>和<code>SET</code>消息，我们首先定义<code>Command</code>类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> bytes::Bytes;

<span style="color:#75715e">#[derive(Debug)]</span>
<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Command</span> {
    Get {
        key: String,
    },
    Set {
        key: String,
        val: <span style="color:#a6e22e">Bytes</span>,
    }
}
</code></pre></div><h3 id="创建channel">创建channel</h3>
<p>在main函数中，我们以如下方式创建<code>mpsc</code>通道：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::sync::mpsc;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// Create a new channel with a capacity of at most 32.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">mut</span> tx, <span style="color:#66d9ef">mut</span> rx) <span style="color:#f92672">=</span> mpsc::channel(<span style="color:#ae81ff">32</span>);
    <span style="color:#75715e">// ... Rest comes here
</span><span style="color:#75715e"></span>}
</code></pre></div><p>这个channel是为了向管理连接的任务发送命令的，多生产者属性使得我们可以在多个任务中发送消息。tx和rx分别是channel的发送器和接收器句柄，它们可以被分配给不同的任务。</p>
<p>当前channel以容量32创建，如果消息的发送速度大于接受速度，则通道会保存未读取的数据。一旦通道中保存的数据超过32，调用<code>send(...).await</code>会导致任务挂起，直到channel有多余空间。</p>
<p>从多个任务发送数据可以通过克隆Sender来实现，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::sync::mpsc;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">mut</span> tx, <span style="color:#66d9ef">mut</span> rx) <span style="color:#f92672">=</span> mpsc::channel(<span style="color:#ae81ff">32</span>);
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> tx2 <span style="color:#f92672">=</span> tx.clone();

    tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
        tx.send(<span style="color:#e6db74">&#34;sending from first handle&#34;</span>).<span style="color:#66d9ef">await</span>;
    });

    tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
        tx2.send(<span style="color:#e6db74">&#34;sending from second handle&#34;</span>).<span style="color:#66d9ef">await</span>;
    });

    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(message) <span style="color:#f92672">=</span> rx.recv().<span style="color:#66d9ef">await</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;GOT = {}&#34;</span>, message);
    }
}
</code></pre></div><p>在上面的代码中，两个数据都被发送到了Reciever，注意mpsc的接收器是无法复制的。</p>
<p>当每个Sender实例都结束生命期后，这就意味着我们无法再向对应的接收器发送任何数据。此时，如果对rx调用recv会得到None，这代表着所有Sender都已经释放，因此channel关闭。</p>
<p>在mini-redis项目中，管理客户端连接的任务将在channel关闭的同时关闭对应的TCP连接，因为不会再有新的命令了，此redis连接作废。</p>
<h3 id="创建manager">创建manager</h3>
<p>现在我们创建一个新的任务，用以管理channel的数据接收和发送。首先，我们建立一个新的与Redis服务的TCP连接，之后我们把从channel中接收到的数据转发到Redis即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> mini_redis::client;
<span style="color:#75715e">// The `move` keyword is used to **move** ownership of `rx` into the task.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> manager <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
    <span style="color:#75715e">// Establish a connection to the server
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> client <span style="color:#f92672">=</span> client::connect(<span style="color:#e6db74">&#34;127.0.0.1:6379&#34;</span>).<span style="color:#66d9ef">await</span>.unwrap();

    <span style="color:#75715e">// Start receiving messages
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(cmd) <span style="color:#f92672">=</span> rx.recv().<span style="color:#66d9ef">await</span> {
        <span style="color:#66d9ef">use</span> Command::<span style="color:#f92672">*</span>;

        <span style="color:#66d9ef">match</span> cmd {
            Get { key } <span style="color:#f92672">=&gt;</span> {
                client.get(<span style="color:#f92672">&amp;</span>key).<span style="color:#66d9ef">await</span>;
            }
            Set { key, val } <span style="color:#f92672">=&gt;</span> {
                client.set(<span style="color:#f92672">&amp;</span>key, val).<span style="color:#66d9ef">await</span>;
            }
        }
    }
});
</code></pre></div><p>现在我们把上一小节的代码修改一下，把数据发送给manager，而不是Redis服务器：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// The `Sender` handles are moved into the tasks. As there are two
</span><span style="color:#75715e">// tasks, we need a second `Sender`.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> tx2 <span style="color:#f92672">=</span> tx.clone();

<span style="color:#75715e">// Spawn two tasks, one gets a key, the other sets a key
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> t1 <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
    <span style="color:#66d9ef">let</span> cmd <span style="color:#f92672">=</span> Command::Get {
        key: <span style="color:#e6db74">&#34;hello&#34;</span>.to_string(),
    };

    tx.send(cmd).<span style="color:#66d9ef">await</span>.unwrap();
});

<span style="color:#66d9ef">let</span> t2 <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
    <span style="color:#66d9ef">let</span> cmd <span style="color:#f92672">=</span> Command::Set {
        key: <span style="color:#e6db74">&#34;foo&#34;</span>.to_string(),
        val: <span style="color:#e6db74">&#34;bar&#34;</span>.into(),
    };

    tx2.send(cmd).<span style="color:#66d9ef">await</span>.unwrap();
});
</code></pre></div><p>在main函数的结尾我们await三个任务的<code>JoinHandle</code>，以保证它们都执行完成：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">t1.<span style="color:#66d9ef">await</span>.unwrap();
t2.<span style="color:#66d9ef">await</span>.unwrap();
manager.<span style="color:#66d9ef">await</span>.unwrap();
</code></pre></div><h3 id="接收响应">接收响应</h3>
<p>最后一步，我们还要把Redis服务器返回的响应内容转发到发送命令的task。<code>GET</code>命令需要获得具体的值，而<code>SET</code>命令需要返回操作结果（失败or成功）。</p>
<p>为了把response传回去，我们使用前面介绍的<code>oneshot</code>通道。它是单生产者，单消费者，并且为单值的消息传递作了优化。在我们的例子中，单值指的是Response。</p>
<p>类似于<code>mpsc</code>，<code>oneshot::channel</code>返回发送器和接收器句柄：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::sync::oneshot;
<span style="color:#66d9ef">let</span> (tx, rx) <span style="color:#f92672">=</span> oneshot::channel();
</code></pre></div><p>不过和mpsc不同，我们不需要设置channel的大小，并且任何一个句柄都是不可复制的。</p>
<p>为了从manager协程接收到响应，在发送命令之前，我们需要先创建一个oneshot通道，然后把发送器一起传给manager即可。为此我们更新一下之前定义的<code>Command</code>类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::sync::oneshot;
<span style="color:#66d9ef">use</span> bytes::Bytes;

<span style="color:#e6db74">/// Multiple different commands are multiplexed over a single channel.
</span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Debug)]</span>
<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Command</span> {
    Get {
        key: String,
        resp: <span style="color:#a6e22e">Responder</span><span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Bytes<span style="color:#f92672">&gt;&gt;</span>,
    },
    Set {
        key: String,
        val: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>,
        resp: <span style="color:#a6e22e">Responder</span><span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>,
    },
}
<span style="color:#e6db74">/// Provided by the requester and used by the manager task to send
</span><span style="color:#e6db74">/// the command response back to the requester.
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Responder</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> oneshot::Sender<span style="color:#f92672">&lt;</span>mini_redis::Result<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>;
</code></pre></div><p>现在我们更新之前的两个发送任务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> t1 <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
    <span style="color:#66d9ef">let</span> (resp_tx, resp_rx) <span style="color:#f92672">=</span> oneshot::channel();
    <span style="color:#66d9ef">let</span> cmd <span style="color:#f92672">=</span> Command::Get {
        key: <span style="color:#e6db74">&#34;hello&#34;</span>.to_string(),
        resp: <span style="color:#a6e22e">resp_tx</span>,
    };
    <span style="color:#75715e">// Send the GET request
</span><span style="color:#75715e"></span>    tx.send(cmd).<span style="color:#66d9ef">await</span>.unwrap();
    <span style="color:#75715e">// Await the response
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> resp_rx.<span style="color:#66d9ef">await</span>;
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;GOT = {:?}&#34;</span>, res);
});

<span style="color:#66d9ef">let</span> t2 <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
    <span style="color:#66d9ef">let</span> (resp_tx, resp_rx) <span style="color:#f92672">=</span> oneshot::channel();
    <span style="color:#66d9ef">let</span> cmd <span style="color:#f92672">=</span> Command::Set {
        key: <span style="color:#e6db74">&#34;foo&#34;</span>.to_string(),
        val: <span style="color:#a6e22e">b</span><span style="color:#e6db74">&#34;bar&#34;</span>.to_vec(),
        resp: <span style="color:#a6e22e">resp_tx</span>,
    };
    <span style="color:#75715e">// Send the SET request
</span><span style="color:#75715e"></span>    tx2.send(cmd).<span style="color:#66d9ef">await</span>.unwrap();
    <span style="color:#75715e">// Await the response
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> resp_rx.<span style="color:#66d9ef">await</span>;
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;GOT = {:?}&#34;</span>, res);
});
</code></pre></div><p>最后再修改一下manager任务，让它把接收到的响应通过Sender发送回去：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(cmd) <span style="color:#f92672">=</span> rx.recv().<span style="color:#66d9ef">await</span> {
    <span style="color:#66d9ef">match</span> cmd {
        Command::Get { key, resp } <span style="color:#f92672">=&gt;</span> {
            <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.get(<span style="color:#f92672">&amp;</span>key).<span style="color:#66d9ef">await</span>;
            <span style="color:#75715e">// Ignore errors
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> resp.send(res);
        }
        Command::Set { key, val, resp } <span style="color:#f92672">=&gt;</span> {
            <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> client.set(<span style="color:#f92672">&amp;</span>key, val.into()).<span style="color:#66d9ef">await</span>;
            <span style="color:#75715e">// Ignore errors
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> resp.send(res);
        }
    }
}
</code></pre></div><p>注意，调用oneshot通道的send是一个同步方法，不需要await。这是因为oneshot的send会立刻知道是否发送成功。当接收器实例已经释放，则send会返回<code>Err</code>，在上面的代码中，我们忽略这一错误，因为这是允许的情况。</p>
<h3 id="背压以及有界channel">背压以及有界channel</h3>
<p>当并发和队列同时出现，我们需要保证队列是有界的，并且系统能够优雅地处理负载。无界地队列最终有可能会占满整个内存，导致系统出现不可预知的错误。</p>
<p>Tokio防止隐式的队列出现。很大一部分原因是异步操作是惰性的，例如下面的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">loop</span> {
    async_op();
}
</code></pre></div><p>如果异步操作是立刻执行的，那么上面的循环会不断地创建新的异步操作，而不会等待上一个操作执行完成，这就产生了隐式的无界队列。基于回调的系统，以及基于eager future的系统特别容易出现这样的错误。</p>
<p>然而，异步Rust和Tokio很好地规避了这一问题，上面的代码在Rust中不会直接执行，async_op本身只是一个Future变量，只有调用await才能让它真正执行，否则就只是一个单纯的死循环，不会占用更多内存。</p>
<p>并发和队列必须显式调用，比如通过如下形式：</p>
<ul>
<li><code>tokio::spawn</code></li>
<li><code>select!</code></li>
<li><code>join!</code></li>
<li><code>mpsc::channel</code></li>
</ul>
<p>当我们做这些调用的时候，请保证所有的并发任务数目是有界的。例如，当编写异步接收TCP请求的循环时，请保证socket的数量是有界的；当使用mpsc通道时，设置一个适当的channel容量，容量大小取决于具体应用的特性。</p>
<p>小心地选取适当的bound是编写可靠的Tokio应用程序的重要一步。</p>
<h2 id="io">I/O</h2>
<p>Tokio里面的I/O操作和标准库里的很像，只不过全部进行了异步化。我们使用两个trait来实现：<code>AsyncRead</code>和<code>AsyncWrite</code>。一些常用的类型都实现了这两种trait，例如<code>TcpStream</code>，<code>File</code>，<code>Stdout</code>。一些常用的数据结构也实现了，如<code>Vec&lt;u8&gt;</code>和<code>&amp;[u8]</code>。</p>
<p>本节将介绍基本的Tokio I/O编程，下一节将介绍更高级的用法。</p>
<h3 id="asyncread和asyncwrite">AsyncRead和AsyncWrite</h3>
<p>这两个trait提供了异步读写字节流的功能，其内部方法实际上不会手动调用，而是通过Tokio提供的工具包<code>AsyncReadExt</code>和<code>AsyncWriteExt</code>来调用。</p>
<p>我们简单看看这些工具包里的方法，注意所有的方法都是异步的，需要使用await才能实际执行。</p>
<h4 id="async-fn-read"><code>async fn read()</code></h4>
<p><code>AsyncReadExt::read()</code>提供了异步读取数据到一个buffer的能力，返回读取到的字节数。</p>
<p><strong>注意</strong>：当<code>read()</code>返回<code>Ok(0)</code>时，说明流已经关闭了，任何后续的读取都会返回0。因此如果读写的是TcpStream，我们可以直接关闭连接了（实际上此时说明TCP连接的对方已经调用close关闭连接，发送了FIN报文）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::fs::File;
<span style="color:#66d9ef">use</span> tokio::io::{self, AsyncReadExt};

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> f <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;foo.txt&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffer <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">10</span>];

    <span style="color:#75715e">// read up to 10 bytes
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> n <span style="color:#f92672">=</span> f.read(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buffer[..]).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;The bytes: {:?}&#34;</span>, <span style="color:#f92672">&amp;</span>buffer[..n]);
    Ok(())
}
</code></pre></div><h4 id="async-fn-read_to_end"><code>async fn read_to_end()</code></h4>
<p><code>AsyncReadExt::read_to_end</code>将从流中读取所有字节，直到遇到EOF。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::io::{self, AsyncReadExt};
<span style="color:#66d9ef">use</span> tokio::fs::File;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> f <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;foo.txt&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffer <span style="color:#f92672">=</span> Vec::new();

    <span style="color:#75715e">// read the whole file
</span><span style="color:#75715e"></span>    f.read_to_end(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buffer).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    Ok(())
}
</code></pre></div><h4 id="async-fn-write"><code>async fn write()</code></h4>
<p><code>AsyncWriteExt::write</code>将一个buffer里面的所有字节都写到流中（不一定能全部写进去），返回实际写入的字节数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::io::{self, AsyncWriteExt};
<span style="color:#66d9ef">use</span> tokio::fs::File;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> file <span style="color:#f92672">=</span> File::create(<span style="color:#e6db74">&#34;foo.txt&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    <span style="color:#75715e">// Writes some prefix of the byte string, but not necessarily all of it.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> n <span style="color:#f92672">=</span> file.write(<span style="color:#e6db74">b&#34;some bytes&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Wrote the first {} bytes of &#39;some bytes&#39;.&#34;</span>, n);
    Ok(())
}
</code></pre></div><h4 id="async-fn-write_all"><code>async fn write_all()</code></h4>
<p><code>AsyncWriteExt::write_all</code>把整个buffer中的数据全部写入，保证全部写入完成才会返回。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::io::{self, AsyncWriteExt};
<span style="color:#66d9ef">use</span> tokio::fs::File;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffer <span style="color:#f92672">=</span> File::create(<span style="color:#e6db74">&#34;foo.txt&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    buffer.write_all(<span style="color:#e6db74">b&#34;some bytes&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    Ok(())
}
</code></pre></div><p>除此之外还有很多其他实用的函数可以查看API文档。</p>
<h3 id="helper函数">Helper函数</h3>
<p>和标准库std一样，<code>tokio::io</code>模块包含很多实用的工具函数，例如<code>tokio::io::copy</code>异步地将一个reader的数据拷贝到一个writer发送出去。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::fs::File;
<span style="color:#66d9ef">use</span> tokio::io;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> reader: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">u8</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">b&#34;hello&#34;</span>;
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> file <span style="color:#f92672">=</span> File::create(<span style="color:#e6db74">&#34;foo.txt&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    io::copy(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> reader, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> file).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    Ok(())
}
</code></pre></div><p>当然这利用了一个事实：字节数组<code>&amp;[u8]</code>实现了<code>AsyncRead</code>。</p>
<h3 id="echo服务器">Echo服务器</h3>
<p>回响服务器是常见的网络编程例子，我们来实现一下。首先需要创建一个<code>TcpListener</code>，接收到来的客户端请求，每个连接的处理都是一致的：从socket中读取数据，然后直接将读取到的数据写回。因此客户端看到的响应就是自己之前发送的数据。</p>
<p>我们将用两种不太一样的策略来实现echo服务器。</p>
<h4 id="使用iocopy实现">使用<code>io::copy</code>实现</h4>
<p>我们首先利用前面介绍的<code>io::copy</code>方法来实现，大致的框架先搭好：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::io;
<span style="color:#66d9ef">use</span> tokio::net::TcpListener;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> listener <span style="color:#f92672">=</span> TcpListener::bind(<span style="color:#e6db74">&#34;127.0.0.1:6142&#34;</span>).<span style="color:#66d9ef">await</span>.unwrap();

    <span style="color:#66d9ef">loop</span> {
        <span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">mut</span> socket, _) <span style="color:#f92672">=</span> listener.accept().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

        tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
            <span style="color:#75715e">// Copy data here
</span><span style="color:#75715e"></span>        });
    }
}
</code></pre></div><p>显然我们只需要在空出来的异步块中填写copy的逻辑即可，注意到<code>TcpStream</code>同时实现了<code>AsyncRead</code>和<code>AsyncWrite</code>，是不是可以直接作为reader和writer调用copy呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// This fails to compile
</span><span style="color:#75715e"></span>io::copy(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> socket, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> socket).<span style="color:#66d9ef">await</span>
</code></pre></div><p>很遗憾上面的代码无法编译，因为我们同时可变引用了两次<code>socket</code>变量（<code>&amp;mut</code>），这在Rust中是不允许的。</p>
<h5 id="拆分成reader和writer">拆分成reader和writer</h5>
<p>如何处理这个问题呢，我们把一个socket拆分成用于reader的句柄和用于writer的句柄。任何同时具有reader和writer属性的类型都可以使用<code>io::aplit</code>拆分，此函数返回reader和writer句柄，而后这两个句柄可以单独用于不同的任务。</p>
<p>例如我们的echo客户端可以如下编写：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::io::{self, AsyncReadExt, AsyncWriteExt};
<span style="color:#66d9ef">use</span> tokio::net::TcpStream;
<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> socket <span style="color:#f92672">=</span> TcpStream::connect(<span style="color:#e6db74">&#34;127.0.0.1:6142&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
    <span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">mut</span> rd, <span style="color:#66d9ef">mut</span> wr) <span style="color:#f92672">=</span> io::split(socket);
    <span style="color:#75715e">// Write data in the background
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> write_task <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
        wr.write_all(<span style="color:#e6db74">b&#34;hello</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
        wr.write_all(<span style="color:#e6db74">b&#34;world</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
        <span style="color:#75715e">// Sometimes, the rust type inferencer needs
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// a little help
</span><span style="color:#75715e"></span>        Ok::<span style="color:#f92672">&lt;</span>_, io::Error<span style="color:#f92672">&gt;</span>(())
    });
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buf <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">128</span>];
    <span style="color:#66d9ef">loop</span> {
        <span style="color:#66d9ef">let</span> n <span style="color:#f92672">=</span> rd.read(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
            <span style="color:#66d9ef">break</span>;
        }
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;GOT {:?}&#34;</span>, <span style="color:#f92672">&amp;</span>buf[..n]);
    }
    Ok(())
}
</code></pre></div><p><code>io::split</code>支持任何实现了<code>AsyncWrite+AsyncRead</code>的类型，在内部它使用<code>Arc</code>和<code>Mutex</code>，这会产生一定的性能损失。对于<code>TcpStream</code>，我们提供了独特的<code>split</code>机制。</p>
<p><code>TcpStream::split</code>接收一个stream的引用作为参数，然会读写句柄。由于我们使用的是引用，因此得到的两个读写句柄不能再用在别的task上了，只能用于当前任务。这个特殊的<code>split</code>函数是零开销的，内部没有使用<code>Arc</code>和<code>Mutex</code>。<code>TcpStream</code>还提供了<code>into_split</code>方法，其提供了可以传递给其他任务的handle，里面用到了<code>Arc</code>。</p>
<p>由于<code>io::copy</code>是在同一task中调用的，我们可以直接使用<code>TcpStream::split</code>来实现拷贝的逻辑：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
    <span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">mut</span> rd, <span style="color:#66d9ef">mut</span> wr) <span style="color:#f92672">=</span> socket.split();
    <span style="color:#66d9ef">if</span> io::copy(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> rd, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> wr).<span style="color:#66d9ef">await</span>.is_err() {
        eprintln<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;failed to copy&#34;</span>);
    }
});
</code></pre></div><h4 id="手动copy">手动copy</h4>
<p>现在我们考虑不用Tokio提供的工具，手动使用<code>read</code>和<code>write_all</code>来实现echo服务。代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::io::{self, AsyncReadExt, AsyncWriteExt};
<span style="color:#66d9ef">use</span> tokio::net::TcpListener;

<span style="color:#75715e">#[tokio::main]</span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> listener <span style="color:#f92672">=</span> TcpListener::bind(<span style="color:#e6db74">&#34;127.0.0.1:6142&#34;</span>).<span style="color:#66d9ef">await</span>.unwrap();
    <span style="color:#66d9ef">loop</span> {
        <span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">mut</span> socket, _) <span style="color:#f92672">=</span> listener.accept().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
        tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buf <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">1024</span>];
            <span style="color:#66d9ef">loop</span> {
                <span style="color:#66d9ef">match</span> socket.read(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf).<span style="color:#66d9ef">await</span> {
                    <span style="color:#75715e">// Return value of `Ok(0)` signifies that the remote has
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// closed
</span><span style="color:#75715e"></span>                    Ok(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span>,
                    Ok(n) <span style="color:#f92672">=&gt;</span> {
                        <span style="color:#75715e">// Copy the data back to socket
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> socket.write_all(<span style="color:#f92672">&amp;</span>buf[..n]).<span style="color:#66d9ef">await</span>.is_err() {
                            <span style="color:#75715e">// Unexpected socket error. There isn&#39;t much we can
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// do here so just stop processing.
</span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">return</span>;
                        }
                    }
                    Err(_) <span style="color:#f92672">=&gt;</span> {
                        <span style="color:#75715e">// Unexpected socket error. There isn&#39;t much we can do
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// here so just stop processing.
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">return</span>;
                    }
                }
            }
        });
    }
}
</code></pre></div><p>我们一步步分析一下上面的代码。首先，创建一个大小为1024的buffer。注意我们使用的是<code>Vec</code>，堆上的动态数组，而不是栈上的基础数组<code>[u8]</code>。因为buffer的使用跨越了await，如果用栈数组来表示buffer，理论上也没问题，但由于它是栈上空间，我们每次处理一个请求都会开启新的一个task，每个task具有一个数据结构，看起来可能像这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Task</span> {
    <span style="color:#75715e">// internal task fields here
</span><span style="color:#75715e"></span>    task: <span style="color:#a6e22e">enum</span> {
        AwaitingRead {
            socket: <span style="color:#a6e22e">TcpStream</span>,
            buf: [BufferType],
        },
        AwaitingWriteAll {
            socket: <span style="color:#a6e22e">TcpStream</span>,
            buf: [BufferType],
        }

    }
}
</code></pre></div><p>如果使用栈数组，它将直接存放在task结构体中，这会导致结构体比较大，而且由于buffer的大小通常设为页的整数倍，这导致task结构的大小有点尴尬。因此，我们推荐使用堆上内存去分配buffer。</p>
<p>当TCP数据流关闭后，我们将从read中读到<code>Ok(0)</code>，此时必须跳出循环，因为后续的读取都会是这个，不跳出的话程序就一定会陷入死循环。</p>
<h2 id="framing">Framing</h2>
<p>我们现在可以应用前面的IO知识实现Mini-Redis的framing层（也叫解码层），指的是将字节流中的数据转化为数据帧的流，一个帧是客户端和服务端数据传输的一个单位。我们使用的Redis通信协议的数据帧如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> bytes::Bytes;

<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Frame</span> {
    Simple(String),
    Error(String),
    Integer(<span style="color:#66d9ef">u64</span>),
    Bulk(Bytes),
    Null,
    Array(Vec<span style="color:#f92672">&lt;</span>Frame<span style="color:#f92672">&gt;</span>),
}
</code></pre></div><p>一个HTTP协议的帧可能会长这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">HttpFrame</span> {
    RequestHead {
        method: <span style="color:#a6e22e">Method</span>,
        uri: <span style="color:#a6e22e">Uri</span>,
        version: <span style="color:#a6e22e">Version</span>,
        headers: <span style="color:#a6e22e">HeaderMap</span>,
    },
    ResponseHead {
        status: <span style="color:#a6e22e">StatusCode</span>,
        version: <span style="color:#a6e22e">Version</span>,
        headers: <span style="color:#a6e22e">HeaderMap</span>,
    },
    BodyChunk {
        chunk: <span style="color:#a6e22e">Bytes</span>,
    },
}
</code></pre></div><p>为了实现Mini-Redis，我们实现一个<code>Connection</code>结构体，它包装一个<code>TcpStream</code>并且读写<code>mini_redis::Frame</code>值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::net::TcpStream;
<span style="color:#66d9ef">use</span> mini_redis::{Frame, Result};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Connection</span> {
    stream: <span style="color:#a6e22e">TcpStream</span>,
    <span style="color:#75715e">// ... other fields here
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">impl</span> Connection {
    <span style="color:#e6db74">/// Read a frame from the connection.
</span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// 
</span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// Returns `None` if EOF is reached
</span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">read_frame</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self)
        -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Frame<span style="color:#f92672">&gt;&gt;</span>
    {
        <span style="color:#75715e">// implementation here
</span><span style="color:#75715e"></span>    }

    <span style="color:#e6db74">/// Write a frame to the connection.
</span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">write_frame</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, frame: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Frame</span>)
        -&gt; Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>
    {
        <span style="color:#75715e">// implementation here
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p>完整的代码在<a href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/connection.rs">这里</a>。</p>
<h3 id="缓冲读">缓冲读</h3>
<p><code>read_frame</code>方法等待接收到一个完整的帧，这是因为一次<code>read</code>读到的数据是不确定的（流式传输的特点），可能有多个帧，也可能只传输了部分帧。因此如果读到了不完整的一个帧，我们将数据存放在缓冲区等待新的数据，如果读到了多个帧，我们一次只返回一个帧，剩下的也放在缓冲区，用于下次<code>read_frame</code>调用。</p>
<p>为了实现这样的想法，<code>Connection</code>需要一个读缓冲区，数据将从socket读到缓冲区，当一个完整的帧解析成功，我们就把对应的数据移除。</p>
<p>我们使用<code>BytesMut</code>作为缓冲区的类型，这是<code>Bytes</code>类型的可变版本。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> bytes::BytesMut;
<span style="color:#66d9ef">use</span> tokio::net::TcpStream;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Connection</span> {
    stream: <span style="color:#a6e22e">TcpStream</span>,
    buffer: <span style="color:#a6e22e">BytesMut</span>,
}

<span style="color:#66d9ef">impl</span> Connection {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(stream: <span style="color:#a6e22e">TcpStream</span>) -&gt; <span style="color:#a6e22e">Connection</span> {
        Connection {
            stream,
            <span style="color:#75715e">// Allocate the buffer with 4kb of capacity.
</span><span style="color:#75715e"></span>            buffer: <span style="color:#a6e22e">BytesMut</span>::with_capacity(<span style="color:#ae81ff">4096</span>),
        }
    }
}
</code></pre></div><p>然后我们再来实现<code>read_frame</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::io::AsyncReadExt;
<span style="color:#66d9ef">use</span> bytes::Buf;
<span style="color:#66d9ef">use</span> mini_redis::Result;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">read_frame</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self)
    -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Frame<span style="color:#f92672">&gt;&gt;</span>
{
    <span style="color:#66d9ef">loop</span> {
        <span style="color:#75715e">// Attempt to parse a frame from the buffered data. If
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// enough data has been buffered, the frame is
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// returned.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(frame) <span style="color:#f92672">=</span> self.parse_frame()<span style="color:#f92672">?</span> {
            <span style="color:#66d9ef">return</span> Ok(Some(frame));
        }

        <span style="color:#75715e">// There is not enough buffered data to read a frame.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Attempt to read more data from the socket.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// On success, the number of bytes is returned. `0`
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// indicates &#34;end of stream&#34;.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> self.stream.read_buf(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.buffer).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span> {
            <span style="color:#75715e">// The remote closed the connection. For this to be
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// a clean shutdown, there should be no data in the
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// read buffer. If there is, this means that the
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// peer closed the socket while sending a frame.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> self.buffer.is_empty() {
                <span style="color:#66d9ef">return</span> Ok(None);
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;connection reset by peer&#34;</span>.into());
            }
        }
    }
}
</code></pre></div><p>我们分析一下，函数的主体在一个循环中，我们首先尝试从现有的缓冲区中解析出一个帧，如果解析成功，我们就可以将帧返回，如果解析不出，说明缓冲区内没有足够的数据。此时我们尝试把socket中接收到的数据读到buffer中，如果读到的数据量为0，要么帧已经完整解析完，socket里面没有数据了，这是正常的连接关闭，如果帧没有解析完，但是对方已经关闭连接，则属于不正常关闭，需要返回Err。</p>
<h4 id="buf-trait"><code>Buf</code> trait</h4>
<p>注意到我们这次从Tcp流中读取数据时用的方法是<code>read_buf</code>，此方法接收的参数必须实现<code>bytes</code>包中的<code>BufMut</code>。</p>
<p>如果我们用<code>Vec&lt;u8&gt;</code>来实现，则可以直接使用前面用到的<code>read()</code>方法，此时需要一个<code>cursor</code>来表示当前缓存的数据的尾部，<code>Connection</code>的定义需要修改为如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> tokio::net::TcpStream;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Connection</span> {
    stream: <span style="color:#a6e22e">TcpStream</span>,
    buffer: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>,
    cursor: <span style="color:#66d9ef">usize</span>,
}

<span style="color:#66d9ef">impl</span> Connection {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(stream: <span style="color:#a6e22e">TcpStream</span>) -&gt; <span style="color:#a6e22e">Connection</span> {
        Connection {
            stream,
            <span style="color:#75715e">// Allocate the buffer with 4kb of capacity.
</span><span style="color:#75715e"></span>            buffer: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">4096</span>],
            cursor: <span style="color:#ae81ff">0</span>,
        }
    }
}
</code></pre></div><p>此时<code>read_frame</code>函数也要修改：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> mini_redis::{Frame, Result};

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">read_frame</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self)
    -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Frame<span style="color:#f92672">&gt;&gt;</span>
{
    <span style="color:#66d9ef">loop</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(frame) <span style="color:#f92672">=</span> self.parse_frame()<span style="color:#f92672">?</span> {
            <span style="color:#66d9ef">return</span> Ok(Some(frame));
        }
        <span style="color:#75715e">// Ensure the buffer has capacity
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> self.buffer.len() <span style="color:#f92672">==</span> self.cursor {
            <span style="color:#75715e">// Grow the buffer
</span><span style="color:#75715e"></span>            self.buffer.resize(self.cursor <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>);
        }
        <span style="color:#75715e">// Read into the buffer, tracking the number
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// of bytes read
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> n <span style="color:#f92672">=</span> self.stream.read(
            <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.buffer[self.cursor..]).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
        <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> n {
            <span style="color:#66d9ef">if</span> self.cursor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
                <span style="color:#66d9ef">return</span> Ok(None);
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;connection reset by peer&#34;</span>.into());
            }
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// Update our cursor
</span><span style="color:#75715e"></span>            self.cursor <span style="color:#f92672">+=</span> n;
        }
    }
}
</code></pre></div><p>可以看到我们必须要使用<code>cursor</code>来保证新读取的数据不会覆盖还未处理完成的数据，同时如果缓冲区的容量用完了，我们必须手动把缓冲区扩容，在<code>parse_frame</code>中，我们需要处理的部分是<code>self.buffer[..self.cursor]</code>。</p>
<p>因为这样的字节数组的处理非常常见，<code>bytes</code>包提供了高级的抽象：<code>Buf</code>和<code>BufMut</code>。<code>Buf</code>指的是可读的数据，<code>BufMut</code>指可写数据类型。当我们将实现了<code>BufMut</code>的实例传入<code>read_buf</code>时，<code>read_buf</code>会帮你处理内部的<code>cursor</code>，这使得外部代码更简洁。</p>
<p>此外，当我们使用<code>Vec&lt;u8&gt;</code>时，buffer必须要初始化，上面的代码就初始化成4KB的大小，每个位置都是0。当我们扩容的时候，新的内容也是初始化为零。初始化过程是非必须的，因为反正后面读的时候也是要覆盖掉原来的数据的。我们的<code>BytesMut</code> 的实现保证了数据不会初始化，省去了这一开销，同时它也在API层面禁止用户访问未初始化的数据。</p>
<h3 id="parsing">Parsing</h3>
<p>现在我们看如何实现<code>parse_frame</code>函数，解析帧需要两步：</p>
<ol>
<li>读完整的一个帧，定位到尾部。</li>
<li>解析这个帧。</li>
</ol>
<p><code>mini_redis</code>包提供了两个函数处理这个事：<code>Frame::check</code>和<code>Frame::parse</code>。</p>
<p>同时我们也会用到<code>Buf</code>，<code>Buf</code>类型的数据将被传入<code>check</code>，check会检查一个帧，同时移动内部的<code>cursor</code>，当其返回时，内部的<code>cursor</code>就会指向帧的尾部。<code>std::io::Cursor</code>就实现了<code>Buf</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> mini_redis::{Frame, Result};
<span style="color:#66d9ef">use</span> mini_redis::frame::Error::Incomplete;
<span style="color:#66d9ef">use</span> bytes::Buf;
<span style="color:#66d9ef">use</span> std::io::Cursor;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse_frame</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self)
    -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Frame<span style="color:#f92672">&gt;&gt;</span>
{
    <span style="color:#75715e">// Create the `T: Buf` type.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buf <span style="color:#f92672">=</span> Cursor::new(<span style="color:#f92672">&amp;</span>self.buffer[..]);
    <span style="color:#75715e">// Check whether a full frame is available
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">match</span> Frame::check(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf) {
        Ok(_) <span style="color:#f92672">=&gt;</span> {
            <span style="color:#75715e">// Get the byte length of the frame
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> buf.position() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
            <span style="color:#75715e">// Reset the internal cursor for the
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// call to `parse`.
</span><span style="color:#75715e"></span>            buf.set_position(<span style="color:#ae81ff">0</span>);
            <span style="color:#75715e">// Parse the frame
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">let</span> frame <span style="color:#f92672">=</span> Frame::parse(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf)<span style="color:#f92672">?</span>;
            <span style="color:#75715e">// Discard the frame from the buffer
</span><span style="color:#75715e"></span>            self.buffer.advance(len);
            <span style="color:#75715e">// Return the frame to the caller.
</span><span style="color:#75715e"></span>            Ok(Some(frame))
        }
        <span style="color:#75715e">// Not enough data has been buffered
</span><span style="color:#75715e"></span>        Err(Incomplete) <span style="color:#f92672">=&gt;</span> Ok(None),
        <span style="color:#75715e">// An error was encountered
</span><span style="color:#75715e"></span>        Err(e) <span style="color:#f92672">=&gt;</span> Err(e.into()),
    }
}
</code></pre></div><p><code>check</code>函数的实现在<a href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/frame.rs#L63-L100">这里</a>。我们不会完整讲解这个函数。</p>
<p>注意到，<code>Buf</code>的API是字节迭代器风格的，例如我们需要查看第一个字节来判断帧的类型，用到的方法是<code>Buf::get_u8</code>，它读取当前<code>cursor</code>位置的1个字节，并将cursor后移1位。还有很多好用的方法，请阅读<a href="https://docs.rs/bytes/0.6/bytes/buf/trait.Buf.html">API文档</a> 。</p>
<h3 id="缓冲写">缓冲写</h3>
<p>framing的另一个API是<code>write_frame(frame)</code>。</p>

        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-category">
              <a href="/categories/rust/">
                Rust
              </a>
            </div>
            
            <div class="post-category">
              <a href="/categories/tokio/">
                Tokio
              </a>
            </div>
            
          </div>
        </div>
        
          <div class="row">
            <div class="col-xs-12">
              
            </div>
          </div>

          



          
          
          <div style="height: 50px;"></div>
          
        

        <div class="site-footer">
  
  
</div>

      </div>
    </div>
  </article>

  

<script>
  
  
    
    
  
</script>

  

</body>

</html>